"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jotai";
exports.ids = ["vendor-chunks/jotai"];
exports.modules = {

/***/ "(ssr)/./node_modules/jotai/esm/react.mjs":
/*!******************************************!*\
  !*** ./node_modules/jotai/esm/react.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   useAtom: () => (/* binding */ useAtom),\n/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),\n/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/./node_modules/jotai/esm/vanilla.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ \n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nconst useStore = (options)=>{\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n};\nconst Provider = ({ children, store })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!store && !storeRef.current) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        value: store || storeRef.current\n    }, children);\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        promise.status = \"pending\";\n        promise.then((v)=>{\n            promise.status = \"fulfilled\";\n            promise.value = v;\n        }, (e)=>{\n            promise.status = \"rejected\";\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nfunction useAtomValue(atom, options) {\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev)=>{\n        const nextValue = store.get(atom);\n        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n            return prev;\n        }\n        return [\n            nextValue,\n            store,\n            atom\n        ];\n    }, void 0, ()=>[\n            store.get(atom),\n            store,\n            atom\n        ]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    const delay = options == null ? void 0 : options.delay;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const unsub = store.sub(atom, ()=>{\n            if (typeof delay === \"number\") {\n                setTimeout(rerender, delay);\n                return;\n            }\n            rerender();\n        });\n        rerender();\n        return unsub;\n    }, [\n        store,\n        atom,\n        delay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    return isPromiseLike(value) ? use(value) : value;\n}\nfunction useSetAtom(atom, options) {\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        if (( false ? 0 : void 0) !== \"production\" && !(\"write\" in atom)) {\n            throw new Error(\"not writable atom\");\n        }\n        return store.set(atom, ...args);\n    }, [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\nfunction useAtom(atom, options) {\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTeUIsV0FBV2QsSUFBSSxFQUFFakIsT0FBTztJQUMvQixNQUFNQyxRQUFRRixTQUFTQztJQUN2QixNQUFNZ0MsVUFBVXJDLGtEQUFXQSxDQUN6QixDQUFDLEdBQUdzQztRQUNGLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCLENBQUUsWUFBV2hCLElBQUcsR0FBSTtZQUM1RixNQUFNLElBQUltQixNQUFNO1FBQ2xCO1FBQ0EsT0FBT25DLE1BQU1vQyxHQUFHLENBQUNwQixTQUFTZ0I7SUFDNUIsR0FDQTtRQUFDaEM7UUFBT2dCO0tBQUs7SUFFZixPQUFPZTtBQUNUO0FBRUEsU0FBU00sUUFBUXJCLElBQUksRUFBRWpCLE9BQU87SUFDNUIsT0FBTztRQUNMZ0IsYUFBYUMsTUFBTWpCO1FBQ25CLHVFQUF1RTtRQUN2RStCLFdBQVdkLE1BQU1qQjtLQUNsQjtBQUNIO0FBRWlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVjaWRvcGhvYmlhLy4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS9yZWFjdC5tanM/YWMzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgUmVhY3RFeHBvcnRzLCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVJlZiwgY3JlYXRlRWxlbWVudCwgdXNlUmVkdWNlciwgdXNlRWZmZWN0LCB1c2VEZWJ1Z1ZhbHVlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldERlZmF1bHRTdG9yZSwgY3JlYXRlU3RvcmUgfSBmcm9tICdqb3RhaS92YW5pbGxhJztcblxuY29uc3QgU3RvcmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuY29uc3QgdXNlU3RvcmUgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnN0b3JlKSB8fCBzdG9yZSB8fCBnZXREZWZhdWx0U3RvcmUoKTtcbn07XG5jb25zdCBQcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuLFxuICBzdG9yZVxufSkgPT4ge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVJlZigpO1xuICBpZiAoIXN0b3JlICYmICFzdG9yZVJlZi5jdXJyZW50KSB7XG4gICAgc3RvcmVSZWYuY3VycmVudCA9IGNyZWF0ZVN0b3JlKCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgU3RvcmVDb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiBzdG9yZSB8fCBzdG9yZVJlZi5jdXJyZW50XG4gICAgfSxcbiAgICBjaGlsZHJlblxuICApO1xufTtcblxuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IHVzZSA9IFJlYWN0RXhwb3J0cy51c2UgfHwgKChwcm9taXNlKSA9PiB7XG4gIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIikge1xuICAgIHRocm93IHByb21pc2UucmVhc29uO1xuICB9IGVsc2Uge1xuICAgIHByb21pc2Uuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgcHJvbWlzZS50aGVuKFxuICAgICAgKHYpID0+IHtcbiAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICBwcm9taXNlLnZhbHVlID0gdjtcbiAgICAgIH0sXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgcHJvbWlzZS5yZWFzb24gPSBlO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufSk7XG5mdW5jdGlvbiB1c2VBdG9tVmFsdWUoYXRvbSwgb3B0aW9ucykge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKG9wdGlvbnMpO1xuICBjb25zdCBbW3ZhbHVlRnJvbVJlZHVjZXIsIHN0b3JlRnJvbVJlZHVjZXIsIGF0b21Gcm9tUmVkdWNlcl0sIHJlcmVuZGVyXSA9IHVzZVJlZHVjZXIoXG4gICAgKHByZXYpID0+IHtcbiAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IHN0b3JlLmdldChhdG9tKTtcbiAgICAgIGlmIChPYmplY3QuaXMocHJldlswXSwgbmV4dFZhbHVlKSAmJiBwcmV2WzFdID09PSBzdG9yZSAmJiBwcmV2WzJdID09PSBhdG9tKSB7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtuZXh0VmFsdWUsIHN0b3JlLCBhdG9tXTtcbiAgICB9LFxuICAgIHZvaWQgMCxcbiAgICAoKSA9PiBbc3RvcmUuZ2V0KGF0b20pLCBzdG9yZSwgYXRvbV1cbiAgKTtcbiAgbGV0IHZhbHVlID0gdmFsdWVGcm9tUmVkdWNlcjtcbiAgaWYgKHN0b3JlRnJvbVJlZHVjZXIgIT09IHN0b3JlIHx8IGF0b21Gcm9tUmVkdWNlciAhPT0gYXRvbSkge1xuICAgIHJlcmVuZGVyKCk7XG4gICAgdmFsdWUgPSBzdG9yZS5nZXQoYXRvbSk7XG4gIH1cbiAgY29uc3QgZGVsYXkgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRlbGF5O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVuc3ViID0gc3RvcmUuc3ViKGF0b20sICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZGVsYXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc2V0VGltZW91dChyZXJlbmRlciwgZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXJlbmRlcigpO1xuICAgIH0pO1xuICAgIHJlcmVuZGVyKCk7XG4gICAgcmV0dXJuIHVuc3ViO1xuICB9LCBbc3RvcmUsIGF0b20sIGRlbGF5XSk7XG4gIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICByZXR1cm4gaXNQcm9taXNlTGlrZSh2YWx1ZSkgPyB1c2UodmFsdWUpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVNldEF0b20oYXRvbSwgb3B0aW9ucykge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKG9wdGlvbnMpO1xuICBjb25zdCBzZXRBdG9tID0gdXNlQ2FsbGJhY2soXG4gICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhKFwid3JpdGVcIiBpbiBhdG9tKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3Qgd3JpdGFibGUgYXRvbVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdG9yZS5zZXQoYXRvbSwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBbc3RvcmUsIGF0b21dXG4gICk7XG4gIHJldHVybiBzZXRBdG9tO1xufVxuXG5mdW5jdGlvbiB1c2VBdG9tKGF0b20sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICB1c2VBdG9tVmFsdWUoYXRvbSwgb3B0aW9ucyksXG4gICAgLy8gV2UgZG8gd3JvbmcgdHlwZSBhc3NlcnRpb24gaGVyZSwgd2hpY2ggcmVzdWx0cyBpbiB0aHJvd2luZyBhbiBlcnJvci5cbiAgICB1c2VTZXRBdG9tKGF0b20sIG9wdGlvbnMpXG4gIF07XG59XG5cbmV4cG9ydCB7IFByb3ZpZGVyLCB1c2VBdG9tLCB1c2VBdG9tVmFsdWUsIHVzZVNldEF0b20sIHVzZVN0b3JlIH07XG4iXSwibmFtZXMiOlsiUmVhY3RFeHBvcnRzIiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VSZWYiLCJjcmVhdGVFbGVtZW50IiwidXNlUmVkdWNlciIsInVzZUVmZmVjdCIsInVzZURlYnVnVmFsdWUiLCJ1c2VDYWxsYmFjayIsImdldERlZmF1bHRTdG9yZSIsImNyZWF0ZVN0b3JlIiwiU3RvcmVDb250ZXh0IiwidXNlU3RvcmUiLCJvcHRpb25zIiwic3RvcmUiLCJQcm92aWRlciIsImNoaWxkcmVuIiwic3RvcmVSZWYiLCJjdXJyZW50IiwidmFsdWUiLCJpc1Byb21pc2VMaWtlIiwieCIsInRoZW4iLCJ1c2UiLCJwcm9taXNlIiwic3RhdHVzIiwicmVhc29uIiwidiIsImUiLCJ1c2VBdG9tVmFsdWUiLCJhdG9tIiwidmFsdWVGcm9tUmVkdWNlciIsInN0b3JlRnJvbVJlZHVjZXIiLCJhdG9tRnJvbVJlZHVjZXIiLCJyZXJlbmRlciIsInByZXYiLCJuZXh0VmFsdWUiLCJnZXQiLCJPYmplY3QiLCJpcyIsImRlbGF5IiwidW5zdWIiLCJzdWIiLCJzZXRUaW1lb3V0IiwidXNlU2V0QXRvbSIsInNldEF0b20iLCJhcmdzIiwiZW52IiwiTU9ERSIsIkVycm9yIiwic2V0IiwidXNlQXRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jotai/esm/vanilla.mjs":
/*!********************************************!*\
  !*** ./node_modules/jotai/esm/vanilla.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atom: () => (/* binding */ atom),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)\n/* harmony export */ });\nlet keyCount = 0;\nfunction atom(read, write) {\n    const key = `atom${++keyCount}`;\n    const config = {\n        toString: ()=>key\n    };\n    if (typeof read === \"function\") {\n        config.read = read;\n    } else {\n        config.init = read;\n        config.read = defaultRead;\n        config.write = defaultWrite;\n    }\n    if (write) {\n        config.write = write;\n    }\n    return config;\n}\nfunction defaultRead(get) {\n    return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n    return set(this, typeof arg === \"function\" ? arg(get(this)) : arg);\n}\nconst isSelfAtom = (atom, a)=>atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom)=>\"init\" in atom;\nconst isActuallyWritableAtom = (atom)=>!!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel)=>{\n    cancelPromiseMap.set(promise, cancel);\n    promise.catch(()=>{}).finally(()=>cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next)=>{\n    const cancel = cancelPromiseMap.get(promise);\n    if (cancel) {\n        cancelPromiseMap.delete(promise);\n        cancel(next);\n    }\n};\nconst resolvePromise = (promise, value)=>{\n    promise.status = \"fulfilled\";\n    promise.value = value;\n};\nconst rejectPromise = (promise, e)=>{\n    promise.status = \"rejected\";\n    promise.reason = e;\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b)=>!!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b)=>!!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a)=>!!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b)=>\"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState)=>{\n    if (\"e\" in atomState) {\n        throw atomState.e;\n    }\n    return atomState.v;\n};\nconst createStore = ()=>{\n    const atomStateMap = /* @__PURE__ */ new WeakMap();\n    const mountedMap = /* @__PURE__ */ new WeakMap();\n    const pendingMap = /* @__PURE__ */ new Map();\n    let storeListenersRev2;\n    let mountedAtoms;\n    if (( false ? 0 : void 0) !== \"production\") {\n        storeListenersRev2 = /* @__PURE__ */ new Set();\n        mountedAtoms = /* @__PURE__ */ new Set();\n    }\n    const getAtomState = (atom)=>atomStateMap.get(atom);\n    const setAtomState = (atom, atomState)=>{\n        if (( false ? 0 : void 0) !== \"production\") {\n            Object.freeze(atomState);\n        }\n        const prevAtomState = getAtomState(atom);\n        atomStateMap.set(atom, atomState);\n        if (!pendingMap.has(atom)) {\n            pendingMap.set(atom, prevAtomState);\n        }\n        if (hasPromiseAtomValue(prevAtomState)) {\n            const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n            if (prevAtomState.v !== next) {\n                cancelPromise(prevAtomState.v, next);\n            }\n        }\n    };\n    const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies)=>{\n        const dependencies = new Map(keepPreviousDependencies ? nextAtomState.d : null);\n        let changed = false;\n        nextDependencies.forEach((aState, a)=>{\n            if (!aState && isSelfAtom(atom, a)) {\n                aState = nextAtomState;\n            }\n            if (aState) {\n                dependencies.set(a, aState);\n                if (nextAtomState.d.get(a) !== aState) {\n                    changed = true;\n                }\n            } else if (( false ? 0 : void 0) !== \"production\") {\n                console.warn(\"[Bug] atom state not found\");\n            }\n        });\n        if (changed || nextAtomState.d.size !== dependencies.size) {\n            nextAtomState.d = dependencies;\n        }\n    };\n    const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies)=>{\n        const prevAtomState = getAtomState(atom);\n        const nextAtomState = {\n            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n            v: value\n        };\n        if (nextDependencies) {\n            updateDependencies(atom, nextAtomState, nextDependencies, keepPreviousDependencies);\n        }\n        if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n            return prevAtomState;\n        }\n        if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n            if (prevAtomState.d === nextAtomState.d) {\n                return prevAtomState;\n            } else {\n                nextAtomState.v = prevAtomState.v;\n            }\n        }\n        setAtomState(atom, nextAtomState);\n        return nextAtomState;\n    };\n    const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise)=>{\n        if (isPromiseLike(valueOrPromise)) {\n            let continuePromise;\n            const updatePromiseDependencies = ()=>{\n                const prevAtomState = getAtomState(atom);\n                if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n                    return;\n                }\n                const nextAtomState = setAtomValue(atom, promise, nextDependencies);\n                if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n                    mountDependencies(atom, nextAtomState, prevAtomState.d);\n                }\n            };\n            const promise = new Promise((resolve, reject)=>{\n                let settled = false;\n                valueOrPromise.then((v)=>{\n                    if (!settled) {\n                        settled = true;\n                        resolvePromise(promise, v);\n                        resolve(v);\n                        updatePromiseDependencies();\n                    }\n                }, (e)=>{\n                    if (!settled) {\n                        settled = true;\n                        rejectPromise(promise, e);\n                        reject(e);\n                        updatePromiseDependencies();\n                    }\n                });\n                continuePromise = (next)=>{\n                    if (!settled) {\n                        settled = true;\n                        next.then((v)=>resolvePromise(promise, v), (e)=>rejectPromise(promise, e));\n                        resolve(next);\n                    }\n                };\n            });\n            promise.orig = valueOrPromise;\n            promise.status = \"pending\";\n            registerCancelPromise(promise, (next)=>{\n                if (next) {\n                    continuePromise(next);\n                }\n                abortPromise == null ? void 0 : abortPromise();\n            });\n            return setAtomValue(atom, promise, nextDependencies, true);\n        }\n        return setAtomValue(atom, valueOrPromise, nextDependencies);\n    };\n    const setAtomError = (atom, error, nextDependencies)=>{\n        const prevAtomState = getAtomState(atom);\n        const nextAtomState = {\n            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n            e: error\n        };\n        if (nextDependencies) {\n            updateDependencies(atom, nextAtomState, nextDependencies);\n        }\n        if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n            return prevAtomState;\n        }\n        setAtomState(atom, nextAtomState);\n        return nextAtomState;\n    };\n    const readAtomState = (atom, force)=>{\n        const atomState = getAtomState(atom);\n        if (!force && atomState) {\n            if (mountedMap.has(atom)) {\n                return atomState;\n            }\n            if (Array.from(atomState.d).every(([a, s])=>{\n                if (a === atom) {\n                    return true;\n                }\n                const aState = readAtomState(a);\n                return aState === s || isEqualAtomValue(aState, s);\n            })) {\n                return atomState;\n            }\n        }\n        const nextDependencies = /* @__PURE__ */ new Map();\n        let isSync = true;\n        const getter = (a)=>{\n            if (isSelfAtom(atom, a)) {\n                const aState2 = getAtomState(a);\n                if (aState2) {\n                    nextDependencies.set(a, aState2);\n                    return returnAtomValue(aState2);\n                }\n                if (hasInitialValue(a)) {\n                    nextDependencies.set(a, void 0);\n                    return a.init;\n                }\n                throw new Error(\"no atom init\");\n            }\n            const aState = readAtomState(a);\n            nextDependencies.set(a, aState);\n            return returnAtomValue(aState);\n        };\n        let controller;\n        let setSelf;\n        const options = {\n            get signal () {\n                if (!controller) {\n                    controller = new AbortController();\n                }\n                return controller.signal;\n            },\n            get setSelf () {\n                if (( false ? 0 : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n                    console.warn(\"setSelf function cannot be used with read-only atom\");\n                }\n                if (!setSelf && isActuallyWritableAtom(atom)) {\n                    setSelf = (...args)=>{\n                        if (( false ? 0 : void 0) !== \"production\" && isSync) {\n                            console.warn(\"setSelf function cannot be called in sync\");\n                        }\n                        if (!isSync) {\n                            return writeAtom(atom, ...args);\n                        }\n                    };\n                }\n                return setSelf;\n            }\n        };\n        try {\n            const valueOrPromise = atom.read(getter, options);\n            return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, ()=>controller == null ? void 0 : controller.abort());\n        } catch (error) {\n            return setAtomError(atom, error, nextDependencies);\n        } finally{\n            isSync = false;\n        }\n    };\n    const readAtom = (atom)=>returnAtomValue(readAtomState(atom));\n    const addAtom = (atom)=>{\n        let mounted = mountedMap.get(atom);\n        if (!mounted) {\n            mounted = mountAtom(atom);\n        }\n        return mounted;\n    };\n    const canUnmountAtom = (atom, mounted)=>!mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n    const delAtom = (atom)=>{\n        const mounted = mountedMap.get(atom);\n        if (mounted && canUnmountAtom(atom, mounted)) {\n            unmountAtom(atom);\n        }\n    };\n    const recomputeDependents = (atom)=>{\n        const getDependents = (a)=>{\n            var _a;\n            const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n            pendingMap.forEach((_, pendingAtom)=>{\n                var _a2;\n                if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a)) {\n                    dependents.add(pendingAtom);\n                }\n            });\n            return dependents;\n        };\n        const topsortedAtoms = new Array();\n        const markedAtoms = /* @__PURE__ */ new Set();\n        const visit = (n)=>{\n            if (markedAtoms.has(n)) {\n                return;\n            }\n            markedAtoms.add(n);\n            for (const m of getDependents(n)){\n                if (n !== m) {\n                    visit(m);\n                }\n            }\n            topsortedAtoms.push(n);\n        };\n        visit(atom);\n        const changedAtoms = /* @__PURE__ */ new Set([\n            atom\n        ]);\n        for(let i = topsortedAtoms.length - 1; i >= 0; --i){\n            const a = topsortedAtoms[i];\n            const prevAtomState = getAtomState(a);\n            if (!prevAtomState) {\n                continue;\n            }\n            let hasChangedDeps = false;\n            for (const dep of prevAtomState.d.keys()){\n                if (dep !== a && changedAtoms.has(dep)) {\n                    hasChangedDeps = true;\n                    break;\n                }\n            }\n            if (hasChangedDeps) {\n                const nextAtomState = readAtomState(a, true);\n                if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n                    changedAtoms.add(a);\n                }\n            }\n        }\n    };\n    const writeAtomState = (atom, ...args)=>{\n        let isSync = true;\n        const getter = (a)=>returnAtomValue(readAtomState(a));\n        const setter = (a, ...args2)=>{\n            let r;\n            if (isSelfAtom(atom, a)) {\n                if (!hasInitialValue(a)) {\n                    throw new Error(\"atom not writable\");\n                }\n                const prevAtomState = getAtomState(a);\n                const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n                if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n                    recomputeDependents(a);\n                }\n            } else {\n                r = writeAtomState(a, ...args2);\n            }\n            if (!isSync) {\n                const flushed = flushPending();\n                if (( false ? 0 : void 0) !== \"production\") {\n                    storeListenersRev2.forEach((l)=>l({\n                            type: \"async-write\",\n                            flushed\n                        }));\n                }\n            }\n            return r;\n        };\n        const result = atom.write(getter, setter, ...args);\n        isSync = false;\n        return result;\n    };\n    const writeAtom = (atom, ...args)=>{\n        const result = writeAtomState(atom, ...args);\n        const flushed = flushPending();\n        if (( false ? 0 : void 0) !== \"production\") {\n            storeListenersRev2.forEach((l)=>l({\n                    type: \"write\",\n                    flushed\n                }));\n        }\n        return result;\n    };\n    const mountAtom = (atom, initialDependent, onMountQueue)=>{\n        var _a;\n        const queue = onMountQueue || [];\n        (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a)=>{\n            const aMounted = mountedMap.get(a);\n            if (aMounted) {\n                aMounted.t.add(atom);\n            } else {\n                if (a !== atom) {\n                    mountAtom(a, atom, queue);\n                }\n            }\n        });\n        readAtomState(atom);\n        const mounted = {\n            t: new Set(initialDependent && [\n                initialDependent\n            ]),\n            l: /* @__PURE__ */ new Set()\n        };\n        mountedMap.set(atom, mounted);\n        if (( false ? 0 : void 0) !== \"production\") {\n            mountedAtoms.add(atom);\n        }\n        if (isActuallyWritableAtom(atom) && atom.onMount) {\n            const { onMount } = atom;\n            queue.push(()=>{\n                const onUnmount = onMount((...args)=>writeAtom(atom, ...args));\n                if (onUnmount) {\n                    mounted.u = onUnmount;\n                }\n            });\n        }\n        if (!onMountQueue) {\n            queue.forEach((f)=>f());\n        }\n        return mounted;\n    };\n    const unmountAtom = (atom)=>{\n        var _a;\n        const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n        if (onUnmount) {\n            onUnmount();\n        }\n        mountedMap.delete(atom);\n        if (( false ? 0 : void 0) !== \"production\") {\n            mountedAtoms.delete(atom);\n        }\n        const atomState = getAtomState(atom);\n        if (atomState) {\n            if (hasPromiseAtomValue(atomState)) {\n                cancelPromise(atomState.v);\n            }\n            atomState.d.forEach((_, a)=>{\n                if (a !== atom) {\n                    const mounted = mountedMap.get(a);\n                    if (mounted) {\n                        mounted.t.delete(atom);\n                        if (canUnmountAtom(a, mounted)) {\n                            unmountAtom(a);\n                        }\n                    }\n                }\n            });\n        } else if (( false ? 0 : void 0) !== \"production\") {\n            console.warn(\"[Bug] could not find atom state to unmount\", atom);\n        }\n    };\n    const mountDependencies = (atom, atomState, prevDependencies)=>{\n        const depSet = new Set(atomState.d.keys());\n        const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n        prevDependencies == null ? void 0 : prevDependencies.forEach((_, a)=>{\n            if (depSet.has(a)) {\n                depSet.delete(a);\n                return;\n            }\n            maybeUnmountAtomSet.add(a);\n            const mounted = mountedMap.get(a);\n            if (mounted) {\n                mounted.t.delete(atom);\n            }\n        });\n        depSet.forEach((a)=>{\n            const mounted = mountedMap.get(a);\n            if (mounted) {\n                mounted.t.add(atom);\n            } else if (mountedMap.has(atom)) {\n                mountAtom(a, atom);\n            }\n        });\n        maybeUnmountAtomSet.forEach((a)=>{\n            const mounted = mountedMap.get(a);\n            if (mounted && canUnmountAtom(a, mounted)) {\n                unmountAtom(a);\n            }\n        });\n    };\n    const flushPending = ()=>{\n        let flushed;\n        if (( false ? 0 : void 0) !== \"production\") {\n            flushed = /* @__PURE__ */ new Set();\n        }\n        while(pendingMap.size){\n            const pending = Array.from(pendingMap);\n            pendingMap.clear();\n            pending.forEach(([atom, prevAtomState])=>{\n                const atomState = getAtomState(atom);\n                if (atomState) {\n                    const mounted = mountedMap.get(atom);\n                    if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n                        mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n                    }\n                    if (mounted && !// Maybe we could `mountDependencies` in `setAtomState`?\n                    (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n                        mounted.l.forEach((listener)=>listener());\n                        if (( false ? 0 : void 0) !== \"production\") {\n                            flushed.add(atom);\n                        }\n                    }\n                } else if (( false ? 0 : void 0) !== \"production\") {\n                    console.warn(\"[Bug] no atom state to flush\");\n                }\n            });\n        }\n        if (( false ? 0 : void 0) !== \"production\") {\n            return flushed;\n        }\n    };\n    const subscribeAtom = (atom, listener)=>{\n        const mounted = addAtom(atom);\n        const flushed = flushPending();\n        const listeners = mounted.l;\n        listeners.add(listener);\n        if (( false ? 0 : void 0) !== \"production\") {\n            storeListenersRev2.forEach((l)=>l({\n                    type: \"sub\",\n                    flushed\n                }));\n        }\n        return ()=>{\n            listeners.delete(listener);\n            delAtom(atom);\n            if (( false ? 0 : void 0) !== \"production\") {\n                storeListenersRev2.forEach((l)=>l({\n                        type: \"unsub\"\n                    }));\n            }\n        };\n    };\n    if (( false ? 0 : void 0) !== \"production\") {\n        return {\n            get: readAtom,\n            set: writeAtom,\n            sub: subscribeAtom,\n            // store dev methods (these are tentative and subject to change without notice)\n            dev_subscribe_store: (l, rev)=>{\n                if (rev !== 2) {\n                    throw new Error(\"The current StoreListener revision is 2.\");\n                }\n                storeListenersRev2.add(l);\n                return ()=>{\n                    storeListenersRev2.delete(l);\n                };\n            },\n            dev_get_mounted_atoms: ()=>mountedAtoms.values(),\n            dev_get_atom_state: (a)=>atomStateMap.get(a),\n            dev_get_mounted: (a)=>mountedMap.get(a),\n            dev_restore_atoms: (values)=>{\n                for (const [atom, valueOrPromise] of values){\n                    if (hasInitialValue(atom)) {\n                        setAtomValueOrPromise(atom, valueOrPromise);\n                        recomputeDependents(atom);\n                    }\n                }\n                const flushed = flushPending();\n                storeListenersRev2.forEach((l)=>l({\n                        type: \"restore\",\n                        flushed\n                    }));\n            }\n        };\n    }\n    return {\n        get: readAtom,\n        set: writeAtom,\n        sub: subscribeAtom\n    };\n};\nlet defaultStore;\nif (( false ? 0 : void 0) !== \"production\") {\n    if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n        ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n    } else {\n        globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n    }\n}\nconst getDefaultStore = ()=>{\n    if (!defaultStore) {\n        if (( false ? 0 : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n            console.warn(\"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\");\n        }\n        defaultStore = createStore();\n    }\n    return defaultStore;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLElBQUlBLFdBQVc7QUFDZixTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLEtBQUs7SUFDdkIsTUFBTUMsTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFSixTQUFTLENBQUM7SUFDL0IsTUFBTUssU0FBUztRQUNiQyxVQUFVLElBQU1GO0lBQ2xCO0lBQ0EsSUFBSSxPQUFPRixTQUFTLFlBQVk7UUFDOUJHLE9BQU9ILElBQUksR0FBR0E7SUFDaEIsT0FBTztRQUNMRyxPQUFPRSxJQUFJLEdBQUdMO1FBQ2RHLE9BQU9ILElBQUksR0FBR007UUFDZEgsT0FBT0YsS0FBSyxHQUFHTTtJQUNqQjtJQUNBLElBQUlOLE9BQU87UUFDVEUsT0FBT0YsS0FBSyxHQUFHQTtJQUNqQjtJQUNBLE9BQU9FO0FBQ1Q7QUFDQSxTQUFTRyxZQUFZRSxHQUFHO0lBQ3RCLE9BQU9BLElBQUksSUFBSTtBQUNqQjtBQUNBLFNBQVNELGFBQWFDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQ2pDLE9BQU9ELElBQ0wsSUFBSSxFQUNKLE9BQU9DLFFBQVEsYUFBYUEsSUFBSUYsSUFBSSxJQUFJLEtBQUtFO0FBRWpEO0FBRUEsTUFBTUMsYUFBYSxDQUFDWixNQUFNYSxJQUFNYixLQUFLYyxXQUFXLEdBQUdkLEtBQUtjLFdBQVcsQ0FBQ0QsS0FBS0EsTUFBTWI7QUFDL0UsTUFBTWUsa0JBQWtCLENBQUNmLE9BQVMsVUFBVUE7QUFDNUMsTUFBTWdCLHlCQUF5QixDQUFDaEIsT0FBUyxDQUFDLENBQUNBLEtBQUtFLEtBQUs7QUFDckQsTUFBTWUsbUJBQW1CLGFBQWEsR0FBRyxJQUFJQztBQUM3QyxNQUFNQyx3QkFBd0IsQ0FBQ0MsU0FBU0M7SUFDdENKLGlCQUFpQlAsR0FBRyxDQUFDVSxTQUFTQztJQUM5QkQsUUFBUUUsS0FBSyxDQUFDLEtBQ2QsR0FBR0MsT0FBTyxDQUFDLElBQU1O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QkFBb0JsSDtvQkFDdEI7Z0JBQ0Y7Z0JBQ0EsTUFBTTBJLFVBQVVDO2dCQUNoQnRGLG1CQUFtQm1CLE9BQU8sQ0FDeEIsQ0FBQ3NDLElBQU1BLEVBQUU7d0JBQUU4QixNQUFNO3dCQUFXRjtvQkFBUTtZQUV4QztRQUNGO0lBQ0Y7SUFDQSxPQUFPO1FBQ0xqSSxLQUFLZ0c7UUFDTC9GLEtBQUs2RjtRQUNMdUQsS0FBS0Y7SUFDUDtBQUNGO0FBQ0EsSUFBSVU7QUFDSixJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGNBQWM7SUFDdEUsSUFBSSxPQUFPQyxXQUFXQyw2QkFBNkIsS0FBSyxVQUFVO1FBQ2hFLEVBQUVELFdBQVdDLDZCQUE2QjtJQUM1QyxPQUFPO1FBQ0xELFdBQVdDLDZCQUE2QixHQUFHO0lBQzdDO0FBQ0Y7QUFDQSxNQUFNQyxrQkFBa0I7SUFDdEIsSUFBSSxDQUFDSCxjQUFjO1FBQ2pCLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCQyxXQUFXQyw2QkFBNkIsS0FBSyxHQUFHO1lBQ3hIOUYsUUFBUUMsSUFBSSxDQUNWO1FBRUo7UUFDQTJGLGVBQWV0SDtJQUNqQjtJQUNBLE9BQU9zSDtBQUNUO0FBRThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVjaWRvcGhvYmlhLy4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS92YW5pbGxhLm1qcz85YjcyIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBrZXlDb3VudCA9IDA7XG5mdW5jdGlvbiBhdG9tKHJlYWQsIHdyaXRlKSB7XG4gIGNvbnN0IGtleSA9IGBhdG9tJHsrK2tleUNvdW50fWA7XG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICB0b1N0cmluZzogKCkgPT4ga2V5XG4gIH07XG4gIGlmICh0eXBlb2YgcmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uZmlnLnJlYWQgPSByZWFkO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5pbml0ID0gcmVhZDtcbiAgICBjb25maWcucmVhZCA9IGRlZmF1bHRSZWFkO1xuICAgIGNvbmZpZy53cml0ZSA9IGRlZmF1bHRXcml0ZTtcbiAgfVxuICBpZiAod3JpdGUpIHtcbiAgICBjb25maWcud3JpdGUgPSB3cml0ZTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlYWQoZ2V0KSB7XG4gIHJldHVybiBnZXQodGhpcyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0V3JpdGUoZ2V0LCBzZXQsIGFyZykge1xuICByZXR1cm4gc2V0KFxuICAgIHRoaXMsXG4gICAgdHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiID8gYXJnKGdldCh0aGlzKSkgOiBhcmdcbiAgKTtcbn1cblxuY29uc3QgaXNTZWxmQXRvbSA9IChhdG9tLCBhKSA9PiBhdG9tLnVuc3RhYmxlX2lzID8gYXRvbS51bnN0YWJsZV9pcyhhKSA6IGEgPT09IGF0b207XG5jb25zdCBoYXNJbml0aWFsVmFsdWUgPSAoYXRvbSkgPT4gXCJpbml0XCIgaW4gYXRvbTtcbmNvbnN0IGlzQWN0dWFsbHlXcml0YWJsZUF0b20gPSAoYXRvbSkgPT4gISFhdG9tLndyaXRlO1xuY29uc3QgY2FuY2VsUHJvbWlzZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVnaXN0ZXJDYW5jZWxQcm9taXNlID0gKHByb21pc2UsIGNhbmNlbCkgPT4ge1xuICBjYW5jZWxQcm9taXNlTWFwLnNldChwcm9taXNlLCBjYW5jZWwpO1xuICBwcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgfSkuZmluYWxseSgoKSA9PiBjYW5jZWxQcm9taXNlTWFwLmRlbGV0ZShwcm9taXNlKSk7XG59O1xuY29uc3QgY2FuY2VsUHJvbWlzZSA9IChwcm9taXNlLCBuZXh0KSA9PiB7XG4gIGNvbnN0IGNhbmNlbCA9IGNhbmNlbFByb21pc2VNYXAuZ2V0KHByb21pc2UpO1xuICBpZiAoY2FuY2VsKSB7XG4gICAgY2FuY2VsUHJvbWlzZU1hcC5kZWxldGUocHJvbWlzZSk7XG4gICAgY2FuY2VsKG5leHQpO1xuICB9XG59O1xuY29uc3QgcmVzb2x2ZVByb21pc2UgPSAocHJvbWlzZSwgdmFsdWUpID0+IHtcbiAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICBwcm9taXNlLnZhbHVlID0gdmFsdWU7XG59O1xuY29uc3QgcmVqZWN0UHJvbWlzZSA9IChwcm9taXNlLCBlKSA9PiB7XG4gIHByb21pc2Uuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICBwcm9taXNlLnJlYXNvbiA9IGU7XG59O1xuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzRXF1YWxBdG9tVmFsdWUgPSAoYSwgYikgPT4gISFhICYmIFwidlwiIGluIGEgJiYgXCJ2XCIgaW4gYiAmJiBPYmplY3QuaXMoYS52LCBiLnYpO1xuY29uc3QgaXNFcXVhbEF0b21FcnJvciA9IChhLCBiKSA9PiAhIWEgJiYgXCJlXCIgaW4gYSAmJiBcImVcIiBpbiBiICYmIE9iamVjdC5pcyhhLmUsIGIuZSk7XG5jb25zdCBoYXNQcm9taXNlQXRvbVZhbHVlID0gKGEpID0+ICEhYSAmJiBcInZcIiBpbiBhICYmIGEudiBpbnN0YW5jZW9mIFByb21pc2U7XG5jb25zdCBpc0VxdWFsUHJvbWlzZUF0b21WYWx1ZSA9IChhLCBiKSA9PiBcInZcIiBpbiBhICYmIFwidlwiIGluIGIgJiYgYS52Lm9yaWcgJiYgYS52Lm9yaWcgPT09IGIudi5vcmlnO1xuY29uc3QgcmV0dXJuQXRvbVZhbHVlID0gKGF0b21TdGF0ZSkgPT4ge1xuICBpZiAoXCJlXCIgaW4gYXRvbVN0YXRlKSB7XG4gICAgdGhyb3cgYXRvbVN0YXRlLmU7XG4gIH1cbiAgcmV0dXJuIGF0b21TdGF0ZS52O1xufTtcbmNvbnN0IGNyZWF0ZVN0b3JlID0gKCkgPT4ge1xuICBjb25zdCBhdG9tU3RhdGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgbW91bnRlZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBwZW5kaW5nTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IHN0b3JlTGlzdGVuZXJzUmV2MjtcbiAgbGV0IG1vdW50ZWRBdG9tcztcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgc3RvcmVMaXN0ZW5lcnNSZXYyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBtb3VudGVkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIGNvbnN0IGdldEF0b21TdGF0ZSA9IChhdG9tKSA9PiBhdG9tU3RhdGVNYXAuZ2V0KGF0b20pO1xuICBjb25zdCBzZXRBdG9tU3RhdGUgPSAoYXRvbSwgYXRvbVN0YXRlKSA9PiB7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGF0b21TdGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgYXRvbVN0YXRlTWFwLnNldChhdG9tLCBhdG9tU3RhdGUpO1xuICAgIGlmICghcGVuZGluZ01hcC5oYXMoYXRvbSkpIHtcbiAgICAgIHBlbmRpbmdNYXAuc2V0KGF0b20sIHByZXZBdG9tU3RhdGUpO1xuICAgIH1cbiAgICBpZiAoaGFzUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlKSkge1xuICAgICAgY29uc3QgbmV4dCA9IFwidlwiIGluIGF0b21TdGF0ZSA/IGF0b21TdGF0ZS52IGluc3RhbmNlb2YgUHJvbWlzZSA/IGF0b21TdGF0ZS52IDogUHJvbWlzZS5yZXNvbHZlKGF0b21TdGF0ZS52KSA6IFByb21pc2UucmVqZWN0KGF0b21TdGF0ZS5lKTtcbiAgICAgIGlmIChwcmV2QXRvbVN0YXRlLnYgIT09IG5leHQpIHtcbiAgICAgICAgY2FuY2VsUHJvbWlzZShwcmV2QXRvbVN0YXRlLnYsIG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgdXBkYXRlRGVwZW5kZW5jaWVzID0gKGF0b20sIG5leHRBdG9tU3RhdGUsIG5leHREZXBlbmRlbmNpZXMsIGtlZXBQcmV2aW91c0RlcGVuZGVuY2llcykgPT4ge1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IG5ldyBNYXAoXG4gICAgICBrZWVwUHJldmlvdXNEZXBlbmRlbmNpZXMgPyBuZXh0QXRvbVN0YXRlLmQgOiBudWxsXG4gICAgKTtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIG5leHREZXBlbmRlbmNpZXMuZm9yRWFjaCgoYVN0YXRlLCBhKSA9PiB7XG4gICAgICBpZiAoIWFTdGF0ZSAmJiBpc1NlbGZBdG9tKGF0b20sIGEpKSB7XG4gICAgICAgIGFTdGF0ZSA9IG5leHRBdG9tU3RhdGU7XG4gICAgICB9XG4gICAgICBpZiAoYVN0YXRlKSB7XG4gICAgICAgIGRlcGVuZGVuY2llcy5zZXQoYSwgYVN0YXRlKTtcbiAgICAgICAgaWYgKG5leHRBdG9tU3RhdGUuZC5nZXQoYSkgIT09IGFTdGF0ZSkge1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltCdWddIGF0b20gc3RhdGUgbm90IGZvdW5kXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VkIHx8IG5leHRBdG9tU3RhdGUuZC5zaXplICE9PSBkZXBlbmRlbmNpZXMuc2l6ZSkge1xuICAgICAgbmV4dEF0b21TdGF0ZS5kID0gZGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0QXRvbVZhbHVlID0gKGF0b20sIHZhbHVlLCBuZXh0RGVwZW5kZW5jaWVzLCBrZWVwUHJldmlvdXNEZXBlbmRlbmNpZXMpID0+IHtcbiAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSB7XG4gICAgICBkOiAocHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgdjogdmFsdWVcbiAgICB9O1xuICAgIGlmIChuZXh0RGVwZW5kZW5jaWVzKSB7XG4gICAgICB1cGRhdGVEZXBlbmRlbmNpZXMoXG4gICAgICAgIGF0b20sXG4gICAgICAgIG5leHRBdG9tU3RhdGUsXG4gICAgICAgIG5leHREZXBlbmRlbmNpZXMsXG4gICAgICAgIGtlZXBQcmV2aW91c0RlcGVuZGVuY2llc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzRXF1YWxBdG9tVmFsdWUocHJldkF0b21TdGF0ZSwgbmV4dEF0b21TdGF0ZSkgJiYgcHJldkF0b21TdGF0ZS5kID09PSBuZXh0QXRvbVN0YXRlLmQpIHtcbiAgICAgIHJldHVybiBwcmV2QXRvbVN0YXRlO1xuICAgIH1cbiAgICBpZiAoaGFzUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlKSAmJiBoYXNQcm9taXNlQXRvbVZhbHVlKG5leHRBdG9tU3RhdGUpICYmIGlzRXF1YWxQcm9taXNlQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpKSB7XG4gICAgICBpZiAocHJldkF0b21TdGF0ZS5kID09PSBuZXh0QXRvbVN0YXRlLmQpIHtcbiAgICAgICAgcmV0dXJuIHByZXZBdG9tU3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0QXRvbVN0YXRlLnYgPSBwcmV2QXRvbVN0YXRlLnY7XG4gICAgICB9XG4gICAgfVxuICAgIHNldEF0b21TdGF0ZShhdG9tLCBuZXh0QXRvbVN0YXRlKTtcbiAgICByZXR1cm4gbmV4dEF0b21TdGF0ZTtcbiAgfTtcbiAgY29uc3Qgc2V0QXRvbVZhbHVlT3JQcm9taXNlID0gKGF0b20sIHZhbHVlT3JQcm9taXNlLCBuZXh0RGVwZW5kZW5jaWVzLCBhYm9ydFByb21pc2UpID0+IHtcbiAgICBpZiAoaXNQcm9taXNlTGlrZSh2YWx1ZU9yUHJvbWlzZSkpIHtcbiAgICAgIGxldCBjb250aW51ZVByb21pc2U7XG4gICAgICBjb25zdCB1cGRhdGVQcm9taXNlRGVwZW5kZW5jaWVzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgICAgICBpZiAoIWhhc1Byb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSkgfHwgcHJldkF0b21TdGF0ZS52ICE9PSBwcm9taXNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSBzZXRBdG9tVmFsdWUoXG4gICAgICAgICAgYXRvbSxcbiAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgIG5leHREZXBlbmRlbmNpZXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG1vdW50ZWRNYXAuaGFzKGF0b20pICYmIHByZXZBdG9tU3RhdGUuZCAhPT0gbmV4dEF0b21TdGF0ZS5kKSB7XG4gICAgICAgICAgbW91bnREZXBlbmRlbmNpZXMoYXRvbSwgbmV4dEF0b21TdGF0ZSwgcHJldkF0b21TdGF0ZS5kKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBzZXR0bGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlT3JQcm9taXNlLnRoZW4oXG4gICAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICAgIGlmICghc2V0dGxlZCkge1xuICAgICAgICAgICAgICBzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgdik7XG4gICAgICAgICAgICAgIHJlc29sdmUodik7XG4gICAgICAgICAgICAgIHVwZGF0ZVByb21pc2VEZXBlbmRlbmNpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNldHRsZWQpIHtcbiAgICAgICAgICAgICAgc2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHJlamVjdFByb21pc2UocHJvbWlzZSwgZSk7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgdXBkYXRlUHJvbWlzZURlcGVuZGVuY2llcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgY29udGludWVQcm9taXNlID0gKG5leHQpID0+IHtcbiAgICAgICAgICBpZiAoIXNldHRsZWQpIHtcbiAgICAgICAgICAgIHNldHRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgbmV4dC50aGVuKFxuICAgICAgICAgICAgICAodikgPT4gcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgdiksXG4gICAgICAgICAgICAgIChlKSA9PiByZWplY3RQcm9taXNlKHByb21pc2UsIGUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzb2x2ZShuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHByb21pc2Uub3JpZyA9IHZhbHVlT3JQcm9taXNlO1xuICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgIHJlZ2lzdGVyQ2FuY2VsUHJvbWlzZShwcm9taXNlLCAobmV4dCkgPT4ge1xuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIGNvbnRpbnVlUHJvbWlzZShuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBhYm9ydFByb21pc2UgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0UHJvbWlzZSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2V0QXRvbVZhbHVlKGF0b20sIHByb21pc2UsIG5leHREZXBlbmRlbmNpZXMsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0QXRvbVZhbHVlKGF0b20sIHZhbHVlT3JQcm9taXNlLCBuZXh0RGVwZW5kZW5jaWVzKTtcbiAgfTtcbiAgY29uc3Qgc2V0QXRvbUVycm9yID0gKGF0b20sIGVycm9yLCBuZXh0RGVwZW5kZW5jaWVzKSA9PiB7XG4gICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0ge1xuICAgICAgZDogKHByZXZBdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZBdG9tU3RhdGUuZCkgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIGU6IGVycm9yXG4gICAgfTtcbiAgICBpZiAobmV4dERlcGVuZGVuY2llcykge1xuICAgICAgdXBkYXRlRGVwZW5kZW5jaWVzKGF0b20sIG5leHRBdG9tU3RhdGUsIG5leHREZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICBpZiAoaXNFcXVhbEF0b21FcnJvcihwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSAmJiBwcmV2QXRvbVN0YXRlLmQgPT09IG5leHRBdG9tU3RhdGUuZCkge1xuICAgICAgcmV0dXJuIHByZXZBdG9tU3RhdGU7XG4gICAgfVxuICAgIHNldEF0b21TdGF0ZShhdG9tLCBuZXh0QXRvbVN0YXRlKTtcbiAgICByZXR1cm4gbmV4dEF0b21TdGF0ZTtcbiAgfTtcbiAgY29uc3QgcmVhZEF0b21TdGF0ZSA9IChhdG9tLCBmb3JjZSkgPT4ge1xuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBpZiAoIWZvcmNlICYmIGF0b21TdGF0ZSkge1xuICAgICAgaWYgKG1vdW50ZWRNYXAuaGFzKGF0b20pKSB7XG4gICAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuZnJvbShhdG9tU3RhdGUuZCkuZXZlcnkoKFthLCBzXSkgPT4ge1xuICAgICAgICBpZiAoYSA9PT0gYXRvbSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFTdGF0ZSA9IHJlYWRBdG9tU3RhdGUoYSk7XG4gICAgICAgIHJldHVybiBhU3RhdGUgPT09IHMgfHwgaXNFcXVhbEF0b21WYWx1ZShhU3RhdGUsIHMpO1xuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV4dERlcGVuZGVuY2llcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IGlzU3luYyA9IHRydWU7XG4gICAgY29uc3QgZ2V0dGVyID0gKGEpID0+IHtcbiAgICAgIGlmIChpc1NlbGZBdG9tKGF0b20sIGEpKSB7XG4gICAgICAgIGNvbnN0IGFTdGF0ZTIgPSBnZXRBdG9tU3RhdGUoYSk7XG4gICAgICAgIGlmIChhU3RhdGUyKSB7XG4gICAgICAgICAgbmV4dERlcGVuZGVuY2llcy5zZXQoYSwgYVN0YXRlMik7XG4gICAgICAgICAgcmV0dXJuIHJldHVybkF0b21WYWx1ZShhU3RhdGUyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzSW5pdGlhbFZhbHVlKGEpKSB7XG4gICAgICAgICAgbmV4dERlcGVuZGVuY2llcy5zZXQoYSwgdm9pZCAwKTtcbiAgICAgICAgICByZXR1cm4gYS5pbml0O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGF0b20gaW5pdFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFTdGF0ZSA9IHJlYWRBdG9tU3RhdGUoYSk7XG4gICAgICBuZXh0RGVwZW5kZW5jaWVzLnNldChhLCBhU3RhdGUpO1xuICAgICAgcmV0dXJuIHJldHVybkF0b21WYWx1ZShhU3RhdGUpO1xuICAgIH07XG4gICAgbGV0IGNvbnRyb2xsZXI7XG4gICAgbGV0IHNldFNlbGY7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBzaWduYWwoKSB7XG4gICAgICAgIGlmICghY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgfSxcbiAgICAgIGdldCBzZXRTZWxmKCkge1xuICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRTZWxmIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggcmVhZC1vbmx5IGF0b21cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZXRTZWxmICYmIGlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkpIHtcbiAgICAgICAgICBzZXRTZWxmID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1N5bmMpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwic2V0U2VsZiBmdW5jdGlvbiBjYW5ub3QgYmUgY2FsbGVkIGluIHN5bmNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICAgICAgICByZXR1cm4gd3JpdGVBdG9tKGF0b20sIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFNlbGY7XG4gICAgICB9XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdmFsdWVPclByb21pc2UgPSBhdG9tLnJlYWQoZ2V0dGVyLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzZXRBdG9tVmFsdWVPclByb21pc2UoXG4gICAgICAgIGF0b20sXG4gICAgICAgIHZhbHVlT3JQcm9taXNlLFxuICAgICAgICBuZXh0RGVwZW5kZW5jaWVzLFxuICAgICAgICAoKSA9PiBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmFib3J0KClcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBzZXRBdG9tRXJyb3IoYXRvbSwgZXJyb3IsIG5leHREZXBlbmRlbmNpZXMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc1N5bmMgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlYWRBdG9tID0gKGF0b20pID0+IHJldHVybkF0b21WYWx1ZShyZWFkQXRvbVN0YXRlKGF0b20pKTtcbiAgY29uc3QgYWRkQXRvbSA9IChhdG9tKSA9PiB7XG4gICAgbGV0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhdG9tKTtcbiAgICBpZiAoIW1vdW50ZWQpIHtcbiAgICAgIG1vdW50ZWQgPSBtb3VudEF0b20oYXRvbSk7XG4gICAgfVxuICAgIHJldHVybiBtb3VudGVkO1xuICB9O1xuICBjb25zdCBjYW5Vbm1vdW50QXRvbSA9IChhdG9tLCBtb3VudGVkKSA9PiAhbW91bnRlZC5sLnNpemUgJiYgKCFtb3VudGVkLnQuc2l6ZSB8fCBtb3VudGVkLnQuc2l6ZSA9PT0gMSAmJiBtb3VudGVkLnQuaGFzKGF0b20pKTtcbiAgY29uc3QgZGVsQXRvbSA9IChhdG9tKSA9PiB7XG4gICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pO1xuICAgIGlmIChtb3VudGVkICYmIGNhblVubW91bnRBdG9tKGF0b20sIG1vdW50ZWQpKSB7XG4gICAgICB1bm1vdW50QXRvbShhdG9tKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlY29tcHV0ZURlcGVuZGVudHMgPSAoYXRvbSkgPT4ge1xuICAgIGNvbnN0IGdldERlcGVuZGVudHMgPSAoYSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZGVwZW5kZW50cyA9IG5ldyBTZXQoKF9hID0gbW91bnRlZE1hcC5nZXQoYSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS50KTtcbiAgICAgIHBlbmRpbmdNYXAuZm9yRWFjaCgoXywgcGVuZGluZ0F0b20pID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgaWYgKChfYTIgPSBnZXRBdG9tU3RhdGUocGVuZGluZ0F0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmQuaGFzKGEpKSB7XG4gICAgICAgICAgZGVwZW5kZW50cy5hZGQocGVuZGluZ0F0b20pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZXBlbmRlbnRzO1xuICAgIH07XG4gICAgY29uc3QgdG9wc29ydGVkQXRvbXMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBtYXJrZWRBdG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgdmlzaXQgPSAobikgPT4ge1xuICAgICAgaWYgKG1hcmtlZEF0b21zLmhhcyhuKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXJrZWRBdG9tcy5hZGQobik7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgZ2V0RGVwZW5kZW50cyhuKSkge1xuICAgICAgICBpZiAobiAhPT0gbSkge1xuICAgICAgICAgIHZpc2l0KG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b3Bzb3J0ZWRBdG9tcy5wdXNoKG4pO1xuICAgIH07XG4gICAgdmlzaXQoYXRvbSk7XG4gICAgY29uc3QgY2hhbmdlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2F0b21dKTtcbiAgICBmb3IgKGxldCBpID0gdG9wc29ydGVkQXRvbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IGEgPSB0b3Bzb3J0ZWRBdG9tc1tpXTtcbiAgICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYSk7XG4gICAgICBpZiAoIXByZXZBdG9tU3RhdGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgaGFzQ2hhbmdlZERlcHMgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIHByZXZBdG9tU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgaWYgKGRlcCAhPT0gYSAmJiBjaGFuZ2VkQXRvbXMuaGFzKGRlcCkpIHtcbiAgICAgICAgICBoYXNDaGFuZ2VkRGVwcyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNDaGFuZ2VkRGVwcykge1xuICAgICAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0gcmVhZEF0b21TdGF0ZShhLCB0cnVlKTtcbiAgICAgICAgaWYgKCFpc0VxdWFsQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpKSB7XG4gICAgICAgICAgY2hhbmdlZEF0b21zLmFkZChhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgd3JpdGVBdG9tU3RhdGUgPSAoYXRvbSwgLi4uYXJncykgPT4ge1xuICAgIGxldCBpc1N5bmMgPSB0cnVlO1xuICAgIGNvbnN0IGdldHRlciA9IChhKSA9PiByZXR1cm5BdG9tVmFsdWUocmVhZEF0b21TdGF0ZShhKSk7XG4gICAgY29uc3Qgc2V0dGVyID0gKGEsIC4uLmFyZ3MyKSA9PiB7XG4gICAgICBsZXQgcjtcbiAgICAgIGlmIChpc1NlbGZBdG9tKGF0b20sIGEpKSB7XG4gICAgICAgIGlmICghaGFzSW5pdGlhbFZhbHVlKGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXRvbSBub3Qgd3JpdGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHNldEF0b21WYWx1ZU9yUHJvbWlzZShhLCBhcmdzMlswXSk7XG4gICAgICAgIGlmICghaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSkge1xuICAgICAgICAgIHJlY29tcHV0ZURlcGVuZGVudHMoYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSB3cml0ZUF0b21TdGF0ZShhLCAuLi5hcmdzMik7XG4gICAgICB9XG4gICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKCk7XG4gICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHN0b3JlTGlzdGVuZXJzUmV2Mi5mb3JFYWNoKFxuICAgICAgICAgICAgKGwpID0+IGwoeyB0eXBlOiBcImFzeW5jLXdyaXRlXCIsIGZsdXNoZWQgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IGF0b20ud3JpdGUoZ2V0dGVyLCBzZXR0ZXIsIC4uLmFyZ3MpO1xuICAgIGlzU3luYyA9IGZhbHNlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IHdyaXRlQXRvbSA9IChhdG9tLCAuLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gd3JpdGVBdG9tU3RhdGUoYXRvbSwgLi4uYXJncyk7XG4gICAgY29uc3QgZmx1c2hlZCA9IGZsdXNoUGVuZGluZygpO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgc3RvcmVMaXN0ZW5lcnNSZXYyLmZvckVhY2goXG4gICAgICAgIChsKSA9PiBsKHsgdHlwZTogXCJ3cml0ZVwiLCBmbHVzaGVkIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb25zdCBtb3VudEF0b20gPSAoYXRvbSwgaW5pdGlhbERlcGVuZGVudCwgb25Nb3VudFF1ZXVlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHF1ZXVlID0gb25Nb3VudFF1ZXVlIHx8IFtdO1xuICAgIChfYSA9IGdldEF0b21TdGF0ZShhdG9tKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmQuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgY29uc3QgYU1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgIGlmIChhTW91bnRlZCkge1xuICAgICAgICBhTW91bnRlZC50LmFkZChhdG9tKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhICE9PSBhdG9tKSB7XG4gICAgICAgICAgbW91bnRBdG9tKGEsIGF0b20sIHF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlYWRBdG9tU3RhdGUoYXRvbSk7XG4gICAgY29uc3QgbW91bnRlZCA9IHtcbiAgICAgIHQ6IG5ldyBTZXQoaW5pdGlhbERlcGVuZGVudCAmJiBbaW5pdGlhbERlcGVuZGVudF0pLFxuICAgICAgbDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgbW91bnRlZE1hcC5zZXQoYXRvbSwgbW91bnRlZCk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBtb3VudGVkQXRvbXMuYWRkKGF0b20pO1xuICAgIH1cbiAgICBpZiAoaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSAmJiBhdG9tLm9uTW91bnQpIHtcbiAgICAgIGNvbnN0IHsgb25Nb3VudCB9ID0gYXRvbTtcbiAgICAgIHF1ZXVlLnB1c2goKCkgPT4ge1xuICAgICAgICBjb25zdCBvblVubW91bnQgPSBvbk1vdW50KCguLi5hcmdzKSA9PiB3cml0ZUF0b20oYXRvbSwgLi4uYXJncykpO1xuICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgbW91bnRlZC51ID0gb25Vbm1vdW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFvbk1vdW50UXVldWUpIHtcbiAgICAgIHF1ZXVlLmZvckVhY2goKGYpID0+IGYoKSk7XG4gICAgfVxuICAgIHJldHVybiBtb3VudGVkO1xuICB9O1xuICBjb25zdCB1bm1vdW50QXRvbSA9IChhdG9tKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG9uVW5tb3VudCA9IChfYSA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EudTtcbiAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICBvblVubW91bnQoKTtcbiAgICB9XG4gICAgbW91bnRlZE1hcC5kZWxldGUoYXRvbSk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBtb3VudGVkQXRvbXMuZGVsZXRlKGF0b20pO1xuICAgIH1cbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKGF0b21TdGF0ZSkge1xuICAgICAgaWYgKGhhc1Byb21pc2VBdG9tVmFsdWUoYXRvbVN0YXRlKSkge1xuICAgICAgICBjYW5jZWxQcm9taXNlKGF0b21TdGF0ZS52KTtcbiAgICAgIH1cbiAgICAgIGF0b21TdGF0ZS5kLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgICAgaWYgKGEgIT09IGF0b20pIHtcbiAgICAgICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYSk7XG4gICAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1vdW50ZWQudC5kZWxldGUoYXRvbSk7XG4gICAgICAgICAgICBpZiAoY2FuVW5tb3VudEF0b20oYSwgbW91bnRlZCkpIHtcbiAgICAgICAgICAgICAgdW5tb3VudEF0b20oYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbQnVnXSBjb3VsZCBub3QgZmluZCBhdG9tIHN0YXRlIHRvIHVubW91bnRcIiwgYXRvbSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudERlcGVuZGVuY2llcyA9IChhdG9tLCBhdG9tU3RhdGUsIHByZXZEZXBlbmRlbmNpZXMpID0+IHtcbiAgICBjb25zdCBkZXBTZXQgPSBuZXcgU2V0KGF0b21TdGF0ZS5kLmtleXMoKSk7XG4gICAgY29uc3QgbWF5YmVVbm1vdW50QXRvbVNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgcHJldkRlcGVuZGVuY2llcyA9PSBudWxsID8gdm9pZCAwIDogcHJldkRlcGVuZGVuY2llcy5mb3JFYWNoKChfLCBhKSA9PiB7XG4gICAgICBpZiAoZGVwU2V0LmhhcyhhKSkge1xuICAgICAgICBkZXBTZXQuZGVsZXRlKGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXliZVVubW91bnRBdG9tU2V0LmFkZChhKTtcbiAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgIG1vdW50ZWQudC5kZWxldGUoYXRvbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVwU2V0LmZvckVhY2goKGEpID0+IHtcbiAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgIG1vdW50ZWQudC5hZGQoYXRvbSk7XG4gICAgICB9IGVsc2UgaWYgKG1vdW50ZWRNYXAuaGFzKGF0b20pKSB7XG4gICAgICAgIG1vdW50QXRvbShhLCBhdG9tKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtYXliZVVubW91bnRBdG9tU2V0LmZvckVhY2goKGEpID0+IHtcbiAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgIGlmIChtb3VudGVkICYmIGNhblVubW91bnRBdG9tKGEsIG1vdW50ZWQpKSB7XG4gICAgICAgIHVubW91bnRBdG9tKGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBmbHVzaFBlbmRpbmcgPSAoKSA9PiB7XG4gICAgbGV0IGZsdXNoZWQ7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBmbHVzaGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB9XG4gICAgd2hpbGUgKHBlbmRpbmdNYXAuc2l6ZSkge1xuICAgICAgY29uc3QgcGVuZGluZyA9IEFycmF5LmZyb20ocGVuZGluZ01hcCk7XG4gICAgICBwZW5kaW5nTWFwLmNsZWFyKCk7XG4gICAgICBwZW5kaW5nLmZvckVhY2goKFthdG9tLCBwcmV2QXRvbVN0YXRlXSkgPT4ge1xuICAgICAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgICAgIGlmIChhdG9tU3RhdGUpIHtcbiAgICAgICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gICAgICAgICAgaWYgKG1vdW50ZWQgJiYgYXRvbVN0YXRlLmQgIT09IChwcmV2QXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2QXRvbVN0YXRlLmQpKSB7XG4gICAgICAgICAgICBtb3VudERlcGVuZGVuY2llcyhhdG9tLCBhdG9tU3RhdGUsIHByZXZBdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZBdG9tU3RhdGUuZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb3VudGVkICYmICEvLyBUT0RPIFRoaXMgc2VlbXMgcHJldHR5IGhhY2t5LiBIb3BlIHRvIGZpeCBpdC5cbiAgICAgICAgICAvLyBNYXliZSB3ZSBjb3VsZCBgbW91bnREZXBlbmRlbmNpZXNgIGluIGBzZXRBdG9tU3RhdGVgP1xuICAgICAgICAgICghaGFzUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlKSAmJiAoaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBhdG9tU3RhdGUpIHx8IGlzRXF1YWxBdG9tRXJyb3IocHJldkF0b21TdGF0ZSwgYXRvbVN0YXRlKSkpKSB7XG4gICAgICAgICAgICBtb3VudGVkLmwuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKCkpO1xuICAgICAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgIGZsdXNoZWQuYWRkKGF0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIltCdWddIG5vIGF0b20gc3RhdGUgdG8gZmx1c2hcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBmbHVzaGVkO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3Vic2NyaWJlQXRvbSA9IChhdG9tLCBsaXN0ZW5lcikgPT4ge1xuICAgIGNvbnN0IG1vdW50ZWQgPSBhZGRBdG9tKGF0b20pO1xuICAgIGNvbnN0IGZsdXNoZWQgPSBmbHVzaFBlbmRpbmcoKTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBtb3VudGVkLmw7XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBzdG9yZUxpc3RlbmVyc1JldjIuZm9yRWFjaChcbiAgICAgICAgKGwpID0+IGwoeyB0eXBlOiBcInN1YlwiLCBmbHVzaGVkIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICBkZWxBdG9tKGF0b20pO1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHN0b3JlTGlzdGVuZXJzUmV2Mi5mb3JFYWNoKChsKSA9PiBsKHsgdHlwZTogXCJ1bnN1YlwiIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0OiByZWFkQXRvbSxcbiAgICAgIHNldDogd3JpdGVBdG9tLFxuICAgICAgc3ViOiBzdWJzY3JpYmVBdG9tLFxuICAgICAgLy8gc3RvcmUgZGV2IG1ldGhvZHMgKHRoZXNlIGFyZSB0ZW50YXRpdmUgYW5kIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlKVxuICAgICAgZGV2X3N1YnNjcmliZV9zdG9yZTogKGwsIHJldikgPT4ge1xuICAgICAgICBpZiAocmV2ICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgU3RvcmVMaXN0ZW5lciByZXZpc2lvbiBpcyAyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZUxpc3RlbmVyc1JldjIuYWRkKGwpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHN0b3JlTGlzdGVuZXJzUmV2Mi5kZWxldGUobCk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGV2X2dldF9tb3VudGVkX2F0b21zOiAoKSA9PiBtb3VudGVkQXRvbXMudmFsdWVzKCksXG4gICAgICBkZXZfZ2V0X2F0b21fc3RhdGU6IChhKSA9PiBhdG9tU3RhdGVNYXAuZ2V0KGEpLFxuICAgICAgZGV2X2dldF9tb3VudGVkOiAoYSkgPT4gbW91bnRlZE1hcC5nZXQoYSksXG4gICAgICBkZXZfcmVzdG9yZV9hdG9tczogKHZhbHVlcykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFthdG9tLCB2YWx1ZU9yUHJvbWlzZV0gb2YgdmFsdWVzKSB7XG4gICAgICAgICAgaWYgKGhhc0luaXRpYWxWYWx1ZShhdG9tKSkge1xuICAgICAgICAgICAgc2V0QXRvbVZhbHVlT3JQcm9taXNlKGF0b20sIHZhbHVlT3JQcm9taXNlKTtcbiAgICAgICAgICAgIHJlY29tcHV0ZURlcGVuZGVudHMoYXRvbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsdXNoZWQgPSBmbHVzaFBlbmRpbmcoKTtcbiAgICAgICAgc3RvcmVMaXN0ZW5lcnNSZXYyLmZvckVhY2goXG4gICAgICAgICAgKGwpID0+IGwoeyB0eXBlOiBcInJlc3RvcmVcIiwgZmx1c2hlZCB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IHJlYWRBdG9tLFxuICAgIHNldDogd3JpdGVBdG9tLFxuICAgIHN1Yjogc3Vic2NyaWJlQXRvbVxuICB9O1xufTtcbmxldCBkZWZhdWx0U3RvcmU7XG5pZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLl9fTlVNQkVSX09GX0pPVEFJX0lOU1RBTkNFU19fID09PSBcIm51bWJlclwiKSB7XG4gICAgKytnbG9iYWxUaGlzLl9fTlVNQkVSX09GX0pPVEFJX0lOU1RBTkNFU19fO1xuICB9IGVsc2Uge1xuICAgIGdsb2JhbFRoaXMuX19OVU1CRVJfT0ZfSk9UQUlfSU5TVEFOQ0VTX18gPSAxO1xuICB9XG59XG5jb25zdCBnZXREZWZhdWx0U3RvcmUgPSAoKSA9PiB7XG4gIGlmICghZGVmYXVsdFN0b3JlKSB7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIGdsb2JhbFRoaXMuX19OVU1CRVJfT0ZfSk9UQUlfSU5TVEFOQ0VTX18gIT09IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSBKb3RhaSBpbnN0YW5jZXMuIEl0IG1heSBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9yIHdpdGggdGhlIGRlZmF1bHQgc3RvcmUuIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvam90YWkvZGlzY3Vzc2lvbnMvMjA0NFwiXG4gICAgICApO1xuICAgIH1cbiAgICBkZWZhdWx0U3RvcmUgPSBjcmVhdGVTdG9yZSgpO1xuICB9XG4gIHJldHVybiBkZWZhdWx0U3RvcmU7XG59O1xuXG5leHBvcnQgeyBhdG9tLCBjcmVhdGVTdG9yZSwgZ2V0RGVmYXVsdFN0b3JlIH07XG4iXSwibmFtZXMiOlsia2V5Q291bnQiLCJhdG9tIiwicmVhZCIsIndyaXRlIiwia2V5IiwiY29uZmlnIiwidG9TdHJpbmciLCJpbml0IiwiZGVmYXVsdFJlYWQiLCJkZWZhdWx0V3JpdGUiLCJnZXQiLCJzZXQiLCJhcmciLCJpc1NlbGZBdG9tIiwiYSIsInVuc3RhYmxlX2lzIiwiaGFzSW5pdGlhbFZhbHVlIiwiaXNBY3R1YWxseVdyaXRhYmxlQXRvbSIsImNhbmNlbFByb21pc2VNYXAiLCJXZWFrTWFwIiwicmVnaXN0ZXJDYW5jZWxQcm9taXNlIiwicHJvbWlzZSIsImNhbmNlbCIsImNhdGNoIiwiZmluYWxseSIsImRlbGV0ZSIsImNhbmNlbFByb21pc2UiLCJuZXh0IiwicmVzb2x2ZVByb21pc2UiLCJ2YWx1ZSIsInN0YXR1cyIsInJlamVjdFByb21pc2UiLCJlIiwicmVhc29uIiwiaXNQcm9taXNlTGlrZSIsIngiLCJ0aGVuIiwiaXNFcXVhbEF0b21WYWx1ZSIsImIiLCJPYmplY3QiLCJpcyIsInYiLCJpc0VxdWFsQXRvbUVycm9yIiwiaGFzUHJvbWlzZUF0b21WYWx1ZSIsIlByb21pc2UiLCJpc0VxdWFsUHJvbWlzZUF0b21WYWx1ZSIsIm9yaWciLCJyZXR1cm5BdG9tVmFsdWUiLCJhdG9tU3RhdGUiLCJjcmVhdGVTdG9yZSIsImF0b21TdGF0ZU1hcCIsIm1vdW50ZWRNYXAiLCJwZW5kaW5nTWFwIiwiTWFwIiwic3RvcmVMaXN0ZW5lcnNSZXYyIiwibW91bnRlZEF0b21zIiwiZW52IiwiTU9ERSIsIlNldCIsImdldEF0b21TdGF0ZSIsInNldEF0b21TdGF0ZSIsImZyZWV6ZSIsInByZXZBdG9tU3RhdGUiLCJoYXMiLCJyZXNvbHZlIiwicmVqZWN0IiwidXBkYXRlRGVwZW5kZW5jaWVzIiwibmV4dEF0b21TdGF0ZSIsIm5leHREZXBlbmRlbmNpZXMiLCJrZWVwUHJldmlvdXNEZXBlbmRlbmNpZXMiLCJkZXBlbmRlbmNpZXMiLCJkIiwiY2hhbmdlZCIsImZvckVhY2giLCJhU3RhdGUiLCJjb25zb2xlIiwid2FybiIsInNpemUiLCJzZXRBdG9tVmFsdWUiLCJzZXRBdG9tVmFsdWVPclByb21pc2UiLCJ2YWx1ZU9yUHJvbWlzZSIsImFib3J0UHJvbWlzZSIsImNvbnRpbnVlUHJvbWlzZSIsInVwZGF0ZVByb21pc2VEZXBlbmRlbmNpZXMiLCJtb3VudERlcGVuZGVuY2llcyIsInNldHRsZWQiLCJzZXRBdG9tRXJyb3IiLCJlcnJvciIsInJlYWRBdG9tU3RhdGUiLCJmb3JjZSIsIkFycmF5IiwiZnJvbSIsImV2ZXJ5IiwicyIsImlzU3luYyIsImdldHRlciIsImFTdGF0ZTIiLCJFcnJvciIsImNvbnRyb2xsZXIiLCJzZXRTZWxmIiwib3B0aW9ucyIsInNpZ25hbCIsIkFib3J0Q29udHJvbGxlciIsImFyZ3MiLCJ3cml0ZUF0b20iLCJhYm9ydCIsInJlYWRBdG9tIiwiYWRkQXRvbSIsIm1vdW50ZWQiLCJtb3VudEF0b20iLCJjYW5Vbm1vdW50QXRvbSIsImwiLCJ0IiwiZGVsQXRvbSIsInVubW91bnRBdG9tIiwicmVjb21wdXRlRGVwZW5kZW50cyIsImdldERlcGVuZGVudHMiLCJfYSIsImRlcGVuZGVudHMiLCJfIiwicGVuZGluZ0F0b20iLCJfYTIiLCJhZGQiLCJ0b3Bzb3J0ZWRBdG9tcyIsIm1hcmtlZEF0b21zIiwidmlzaXQiLCJuIiwibSIsInB1c2giLCJjaGFuZ2VkQXRvbXMiLCJpIiwibGVuZ3RoIiwiaGFzQ2hhbmdlZERlcHMiLCJkZXAiLCJrZXlzIiwid3JpdGVBdG9tU3RhdGUiLCJzZXR0ZXIiLCJhcmdzMiIsInIiLCJmbHVzaGVkIiwiZmx1c2hQZW5kaW5nIiwidHlwZSIsInJlc3VsdCIsImluaXRpYWxEZXBlbmRlbnQiLCJvbk1vdW50UXVldWUiLCJxdWV1ZSIsImFNb3VudGVkIiwib25Nb3VudCIsIm9uVW5tb3VudCIsInUiLCJmIiwicHJldkRlcGVuZGVuY2llcyIsImRlcFNldCIsIm1heWJlVW5tb3VudEF0b21TZXQiLCJwZW5kaW5nIiwiY2xlYXIiLCJsaXN0ZW5lciIsInN1YnNjcmliZUF0b20iLCJsaXN0ZW5lcnMiLCJzdWIiLCJkZXZfc3Vic2NyaWJlX3N0b3JlIiwicmV2IiwiZGV2X2dldF9tb3VudGVkX2F0b21zIiwidmFsdWVzIiwiZGV2X2dldF9hdG9tX3N0YXRlIiwiZGV2X2dldF9tb3VudGVkIiwiZGV2X3Jlc3RvcmVfYXRvbXMiLCJkZWZhdWx0U3RvcmUiLCJnbG9iYWxUaGlzIiwiX19OVU1CRVJfT0ZfSk9UQUlfSU5TVEFOQ0VTX18iLCJnZXREZWZhdWx0U3RvcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/vanilla.mjs\n");

/***/ })

};
;