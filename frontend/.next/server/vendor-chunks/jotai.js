"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jotai";
exports.ids = ["vendor-chunks/jotai"];
exports.modules = {

/***/ "(ssr)/./node_modules/jotai/esm/react.mjs":
/*!******************************************!*\
  !*** ./node_modules/jotai/esm/react.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   useAtom: () => (/* binding */ useAtom),\n/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),\n/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../../Users/user/AppData/Roaming/npm/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/./node_modules/jotai/esm/vanilla.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ \n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nconst useStore = (options)=>{\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n};\nconst Provider = ({ children, store })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!store && !storeRef.current) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        value: store || storeRef.current\n    }, children);\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        promise.status = \"pending\";\n        promise.then((v)=>{\n            promise.status = \"fulfilled\";\n            promise.value = v;\n        }, (e)=>{\n            promise.status = \"rejected\";\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nfunction useAtomValue(atom, options) {\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev)=>{\n        const nextValue = store.get(atom);\n        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n            return prev;\n        }\n        return [\n            nextValue,\n            store,\n            atom\n        ];\n    }, void 0, ()=>[\n            store.get(atom),\n            store,\n            atom\n        ]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    const delay = options == null ? void 0 : options.delay;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const unsub = store.sub(atom, ()=>{\n            if (typeof delay === \"number\") {\n                setTimeout(rerender, delay);\n                return;\n            }\n            rerender();\n        });\n        rerender();\n        return unsub;\n    }, [\n        store,\n        atom,\n        delay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    return isPromiseLike(value) ? use(value) : value;\n}\nfunction useSetAtom(atom, options) {\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        if (( false ? 0 : void 0) !== \"production\" && !(\"write\" in atom)) {\n            throw new Error(\"not writable atom\");\n        }\n        return store.set(atom, ...args);\n    }, [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\nfunction useAtom(atom, options) {\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTeUIsV0FBV2QsSUFBSSxFQUFFakIsT0FBTztJQUMvQixNQUFNQyxRQUFRRixTQUFTQztJQUN2QixNQUFNZ0MsVUFBVXJDLGtEQUFXQSxDQUN6QixDQUFDLEdBQUdzQztRQUNGLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCLENBQUUsWUFBV2hCLElBQUcsR0FBSTtZQUM1RixNQUFNLElBQUltQixNQUFNO1FBQ2xCO1FBQ0EsT0FBT25DLE1BQU1vQyxHQUFHLENBQUNwQixTQUFTZ0I7SUFDNUIsR0FDQTtRQUFDaEM7UUFBT2dCO0tBQUs7SUFFZixPQUFPZTtBQUNUO0FBRUEsU0FBU00sUUFBUXJCLElBQUksRUFBRWpCLE9BQU87SUFDNUIsT0FBTztRQUNMZ0IsYUFBYUMsTUFBTWpCO1FBQ25CLHVFQUF1RTtRQUN2RStCLFdBQVdkLE1BQU1qQjtLQUNsQjtBQUNIO0FBRWlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVjaWRvcGhvYmlhLy4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS9yZWFjdC5tanM/YWMzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgUmVhY3RFeHBvcnRzLCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVJlZiwgY3JlYXRlRWxlbWVudCwgdXNlUmVkdWNlciwgdXNlRWZmZWN0LCB1c2VEZWJ1Z1ZhbHVlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldERlZmF1bHRTdG9yZSwgY3JlYXRlU3RvcmUgfSBmcm9tICdqb3RhaS92YW5pbGxhJztcblxuY29uc3QgU3RvcmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuY29uc3QgdXNlU3RvcmUgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnN0b3JlKSB8fCBzdG9yZSB8fCBnZXREZWZhdWx0U3RvcmUoKTtcbn07XG5jb25zdCBQcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuLFxuICBzdG9yZVxufSkgPT4ge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVJlZigpO1xuICBpZiAoIXN0b3JlICYmICFzdG9yZVJlZi5jdXJyZW50KSB7XG4gICAgc3RvcmVSZWYuY3VycmVudCA9IGNyZWF0ZVN0b3JlKCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgU3RvcmVDb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiBzdG9yZSB8fCBzdG9yZVJlZi5jdXJyZW50XG4gICAgfSxcbiAgICBjaGlsZHJlblxuICApO1xufTtcblxuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IHVzZSA9IFJlYWN0RXhwb3J0cy51c2UgfHwgKChwcm9taXNlKSA9PiB7XG4gIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIikge1xuICAgIHRocm93IHByb21pc2UucmVhc29uO1xuICB9IGVsc2Uge1xuICAgIHByb21pc2Uuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgcHJvbWlzZS50aGVuKFxuICAgICAgKHYpID0+IHtcbiAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICBwcm9taXNlLnZhbHVlID0gdjtcbiAgICAgIH0sXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgcHJvbWlzZS5yZWFzb24gPSBlO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufSk7XG5mdW5jdGlvbiB1c2VBdG9tVmFsdWUoYXRvbSwgb3B0aW9ucykge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKG9wdGlvbnMpO1xuICBjb25zdCBbW3ZhbHVlRnJvbVJlZHVjZXIsIHN0b3JlRnJvbVJlZHVjZXIsIGF0b21Gcm9tUmVkdWNlcl0sIHJlcmVuZGVyXSA9IHVzZVJlZHVjZXIoXG4gICAgKHByZXYpID0+IHtcbiAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IHN0b3JlLmdldChhdG9tKTtcbiAgICAgIGlmIChPYmplY3QuaXMocHJldlswXSwgbmV4dFZhbHVlKSAmJiBwcmV2WzFdID09PSBzdG9yZSAmJiBwcmV2WzJdID09PSBhdG9tKSB7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtuZXh0VmFsdWUsIHN0b3JlLCBhdG9tXTtcbiAgICB9LFxuICAgIHZvaWQgMCxcbiAgICAoKSA9PiBbc3RvcmUuZ2V0KGF0b20pLCBzdG9yZSwgYXRvbV1cbiAgKTtcbiAgbGV0IHZhbHVlID0gdmFsdWVGcm9tUmVkdWNlcjtcbiAgaWYgKHN0b3JlRnJvbVJlZHVjZXIgIT09IHN0b3JlIHx8IGF0b21Gcm9tUmVkdWNlciAhPT0gYXRvbSkge1xuICAgIHJlcmVuZGVyKCk7XG4gICAgdmFsdWUgPSBzdG9yZS5nZXQoYXRvbSk7XG4gIH1cbiAgY29uc3QgZGVsYXkgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRlbGF5O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVuc3ViID0gc3RvcmUuc3ViKGF0b20sICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZGVsYXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc2V0VGltZW91dChyZXJlbmRlciwgZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXJlbmRlcigpO1xuICAgIH0pO1xuICAgIHJlcmVuZGVyKCk7XG4gICAgcmV0dXJuIHVuc3ViO1xuICB9LCBbc3RvcmUsIGF0b20sIGRlbGF5XSk7XG4gIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICByZXR1cm4gaXNQcm9taXNlTGlrZSh2YWx1ZSkgPyB1c2UodmFsdWUpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVNldEF0b20oYXRvbSwgb3B0aW9ucykge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKG9wdGlvbnMpO1xuICBjb25zdCBzZXRBdG9tID0gdXNlQ2FsbGJhY2soXG4gICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhKFwid3JpdGVcIiBpbiBhdG9tKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3Qgd3JpdGFibGUgYXRvbVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdG9yZS5zZXQoYXRvbSwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBbc3RvcmUsIGF0b21dXG4gICk7XG4gIHJldHVybiBzZXRBdG9tO1xufVxuXG5mdW5jdGlvbiB1c2VBdG9tKGF0b20sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICB1c2VBdG9tVmFsdWUoYXRvbSwgb3B0aW9ucyksXG4gICAgLy8gV2UgZG8gd3JvbmcgdHlwZSBhc3NlcnRpb24gaGVyZSwgd2hpY2ggcmVzdWx0cyBpbiB0aHJvd2luZyBhbiBlcnJvci5cbiAgICB1c2VTZXRBdG9tKGF0b20sIG9wdGlvbnMpXG4gIF07XG59XG5cbmV4cG9ydCB7IFByb3ZpZGVyLCB1c2VBdG9tLCB1c2VBdG9tVmFsdWUsIHVzZVNldEF0b20sIHVzZVN0b3JlIH07XG4iXSwibmFtZXMiOlsiUmVhY3RFeHBvcnRzIiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VSZWYiLCJjcmVhdGVFbGVtZW50IiwidXNlUmVkdWNlciIsInVzZUVmZmVjdCIsInVzZURlYnVnVmFsdWUiLCJ1c2VDYWxsYmFjayIsImdldERlZmF1bHRTdG9yZSIsImNyZWF0ZVN0b3JlIiwiU3RvcmVDb250ZXh0IiwidXNlU3RvcmUiLCJvcHRpb25zIiwic3RvcmUiLCJQcm92aWRlciIsImNoaWxkcmVuIiwic3RvcmVSZWYiLCJjdXJyZW50IiwidmFsdWUiLCJpc1Byb21pc2VMaWtlIiwieCIsInRoZW4iLCJ1c2UiLCJwcm9taXNlIiwic3RhdHVzIiwicmVhc29uIiwidiIsImUiLCJ1c2VBdG9tVmFsdWUiLCJhdG9tIiwidmFsdWVGcm9tUmVkdWNlciIsInN0b3JlRnJvbVJlZHVjZXIiLCJhdG9tRnJvbVJlZHVjZXIiLCJyZXJlbmRlciIsInByZXYiLCJuZXh0VmFsdWUiLCJnZXQiLCJPYmplY3QiLCJpcyIsImRlbGF5IiwidW5zdWIiLCJzdWIiLCJzZXRUaW1lb3V0IiwidXNlU2V0QXRvbSIsInNldEF0b20iLCJhcmdzIiwiZW52IiwiTU9ERSIsIkVycm9yIiwic2V0IiwidXNlQXRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jotai/esm/vanilla.mjs":
/*!********************************************!*\
  !*** ./node_modules/jotai/esm/vanilla.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atom: () => (/* binding */ atom),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)\n/* harmony export */ });\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingStack = [];\n  const pendingMap = /* @__PURE__ */ new WeakMap();\n  let storeListenersRev2;\n  let mountedAtoms;\n  if (( false ? 0 : void 0) !== \"production\") {\n    storeListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const addPendingDependent = (atom, atomState) => {\n    atomState.d.forEach((_, a) => {\n      var _a;\n      if (!pendingMap.has(a)) {\n        const aState = getAtomState(a);\n        (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(a);\n        pendingMap.set(a, [aState, /* @__PURE__ */ new Set()]);\n        if (aState) {\n          addPendingDependent(a, aState);\n        }\n      }\n      pendingMap.get(a)[1].add(atom);\n    });\n  };\n  const setAtomState = (atom, atomState) => {\n    var _a;\n    if (( false ? 0 : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = getAtomState(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(atom);\n      pendingMap.set(atom, [prevAtomState, /* @__PURE__ */ new Set()]);\n      addPendingDependent(atom, atomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies) => {\n    const dependencies = new Map(\n      keepPreviousDependencies ? nextAtomState.d : null\n    );\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && isSelfAtom(atom, a)) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if (( false ? 0 : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(\n        atom,\n        nextAtomState,\n        nextDependencies,\n        keepPreviousDependencies\n      );\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(\n          atom,\n          promise,\n          nextDependencies\n        );\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              resolvePromise(promise, v);\n              resolve(v);\n              updatePromiseDependencies();\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              rejectPromise(promise, e);\n              reject(e);\n              updatePromiseDependencies();\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies, true);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom) {\n          return true;\n        }\n        const aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if (( false ? 0 : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if (( false ? 0 : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const getDependents = (a) => {\n      var _a, _b;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      (_b = pendingMap.get(a)) == null ? void 0 : _b[1].forEach((dependent) => {\n        dependents.add(dependent);\n      });\n      return dependents;\n    };\n    const topsortedAtoms = new Array();\n    const markedAtoms = /* @__PURE__ */ new Set();\n    const visit = (n) => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const prevAtomState = getAtomState(a);\n      if (!prevAtomState) {\n        continue;\n      }\n      let hasChangedDeps = false;\n      for (const dep of prevAtomState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        const nextAtomState = readAtomState(a, true);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          changedAtoms.add(a);\n        }\n      }\n    }\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending([a]);\n        if (( false ? 0 : void 0) !== \"production\") {\n          storeListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    pendingStack.push(/* @__PURE__ */ new Set([atom]));\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending(pendingStack.pop());\n    if (( false ? 0 : void 0) !== \"production\") {\n      storeListenersRev2.forEach((l) => l({ type: \"write\", flushed }));\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\n    var _a;\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom, queue);\n        }\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if (( false ? 0 : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const { onMount } = atom;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach((f) => f());\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if (( false ? 0 : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (( false ? 0 : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      maybeUnmountAtomSet.add(a);\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n    maybeUnmountAtomSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted && canUnmountAtom(a, mounted)) {\n        unmountAtom(a);\n      }\n    });\n  };\n  const flushPending = (pendingAtoms) => {\n    let flushed;\n    if (( false ? 0 : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    const pending = [];\n    const collectPending = (pendingAtom) => {\n      var _a;\n      if (!pendingMap.has(pendingAtom)) {\n        return;\n      }\n      const [prevAtomState, dependents] = pendingMap.get(pendingAtom);\n      pendingMap.delete(pendingAtom);\n      pending.push([pendingAtom, prevAtomState]);\n      dependents.forEach(collectPending);\n      (_a = getAtomState(pendingAtom)) == null ? void 0 : _a.d.forEach((_, a) => collectPending(a));\n    };\n    pendingAtoms.forEach(collectPending);\n    pending.forEach(([atom, prevAtomState]) => {\n      const atomState = getAtomState(atom);\n      if (!atomState) {\n        if (( false ? 0 : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n        return;\n      }\n      if (atomState !== prevAtomState) {\n        const mounted = mountedMap.get(atom);\n        if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n        // Maybe we could `mountDependencies` in `setAtomState`?\n        (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n          mounted.l.forEach((listener) => listener());\n          if (( false ? 0 : void 0) !== \"production\") {\n            flushed.add(atom);\n          }\n        }\n      }\n    });\n    if (( false ? 0 : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    const flushed = flushPending([atom]);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if (( false ? 0 : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if (( false ? 0 : void 0) !== \"production\") {\n        storeListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if (( false ? 0 : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l, rev) => {\n        if (rev !== 2) {\n          throw new Error(\"The current StoreListener revision is 2.\");\n        }\n        storeListenersRev2.add(l);\n        return () => {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        pendingStack.push(/* @__PURE__ */ new Set());\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending(pendingStack.pop());\n        storeListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nif (( false ? 0 : void 0) !== \"production\") {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  } else {\n    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n  }\n}\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    if (( false ? 0 : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn(\n        \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n      );\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBZSxHQUFHLENBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBZSxHQUFHLENBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsVUFBVSxNQUFlLEdBQUcsQ0FBb0I7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGFBQWEsTUFBZSxHQUFHLENBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQWUsR0FBRyxDQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssTUFBZSxHQUFHLENBQW9CO0FBQzNDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBZSxHQUFHLENBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVjaWRvcGhvYmlhLy4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS92YW5pbGxhLm1qcz9kZTI5Il0sInNvdXJjZXNDb250ZW50IjpbImxldCBrZXlDb3VudCA9IDA7XG5mdW5jdGlvbiBhdG9tKHJlYWQsIHdyaXRlKSB7XG4gIGNvbnN0IGtleSA9IGBhdG9tJHsrK2tleUNvdW50fWA7XG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICB0b1N0cmluZzogKCkgPT4ga2V5XG4gIH07XG4gIGlmICh0eXBlb2YgcmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uZmlnLnJlYWQgPSByZWFkO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5pbml0ID0gcmVhZDtcbiAgICBjb25maWcucmVhZCA9IGRlZmF1bHRSZWFkO1xuICAgIGNvbmZpZy53cml0ZSA9IGRlZmF1bHRXcml0ZTtcbiAgfVxuICBpZiAod3JpdGUpIHtcbiAgICBjb25maWcud3JpdGUgPSB3cml0ZTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlYWQoZ2V0KSB7XG4gIHJldHVybiBnZXQodGhpcyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0V3JpdGUoZ2V0LCBzZXQsIGFyZykge1xuICByZXR1cm4gc2V0KFxuICAgIHRoaXMsXG4gICAgdHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiID8gYXJnKGdldCh0aGlzKSkgOiBhcmdcbiAgKTtcbn1cblxuY29uc3QgaXNTZWxmQXRvbSA9IChhdG9tLCBhKSA9PiBhdG9tLnVuc3RhYmxlX2lzID8gYXRvbS51bnN0YWJsZV9pcyhhKSA6IGEgPT09IGF0b207XG5jb25zdCBoYXNJbml0aWFsVmFsdWUgPSAoYXRvbSkgPT4gXCJpbml0XCIgaW4gYXRvbTtcbmNvbnN0IGlzQWN0dWFsbHlXcml0YWJsZUF0b20gPSAoYXRvbSkgPT4gISFhdG9tLndyaXRlO1xuY29uc3QgY2FuY2VsUHJvbWlzZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVnaXN0ZXJDYW5jZWxQcm9taXNlID0gKHByb21pc2UsIGNhbmNlbCkgPT4ge1xuICBjYW5jZWxQcm9taXNlTWFwLnNldChwcm9taXNlLCBjYW5jZWwpO1xuICBwcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgfSkuZmluYWxseSgoKSA9PiBjYW5jZWxQcm9taXNlTWFwLmRlbGV0ZShwcm9taXNlKSk7XG59O1xuY29uc3QgY2FuY2VsUHJvbWlzZSA9IChwcm9taXNlLCBuZXh0KSA9PiB7XG4gIGNvbnN0IGNhbmNlbCA9IGNhbmNlbFByb21pc2VNYXAuZ2V0KHByb21pc2UpO1xuICBpZiAoY2FuY2VsKSB7XG4gICAgY2FuY2VsUHJvbWlzZU1hcC5kZWxldGUocHJvbWlzZSk7XG4gICAgY2FuY2VsKG5leHQpO1xuICB9XG59O1xuY29uc3QgcmVzb2x2ZVByb21pc2UgPSAocHJvbWlzZSwgdmFsdWUpID0+IHtcbiAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICBwcm9taXNlLnZhbHVlID0gdmFsdWU7XG59O1xuY29uc3QgcmVqZWN0UHJvbWlzZSA9IChwcm9taXNlLCBlKSA9PiB7XG4gIHByb21pc2Uuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICBwcm9taXNlLnJlYXNvbiA9IGU7XG59O1xuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzRXF1YWxBdG9tVmFsdWUgPSAoYSwgYikgPT4gISFhICYmIFwidlwiIGluIGEgJiYgXCJ2XCIgaW4gYiAmJiBPYmplY3QuaXMoYS52LCBiLnYpO1xuY29uc3QgaXNFcXVhbEF0b21FcnJvciA9IChhLCBiKSA9PiAhIWEgJiYgXCJlXCIgaW4gYSAmJiBcImVcIiBpbiBiICYmIE9iamVjdC5pcyhhLmUsIGIuZSk7XG5jb25zdCBoYXNQcm9taXNlQXRvbVZhbHVlID0gKGEpID0+ICEhYSAmJiBcInZcIiBpbiBhICYmIGEudiBpbnN0YW5jZW9mIFByb21pc2U7XG5jb25zdCBpc0VxdWFsUHJvbWlzZUF0b21WYWx1ZSA9IChhLCBiKSA9PiBcInZcIiBpbiBhICYmIFwidlwiIGluIGIgJiYgYS52Lm9yaWcgJiYgYS52Lm9yaWcgPT09IGIudi5vcmlnO1xuY29uc3QgcmV0dXJuQXRvbVZhbHVlID0gKGF0b21TdGF0ZSkgPT4ge1xuICBpZiAoXCJlXCIgaW4gYXRvbVN0YXRlKSB7XG4gICAgdGhyb3cgYXRvbVN0YXRlLmU7XG4gIH1cbiAgcmV0dXJuIGF0b21TdGF0ZS52O1xufTtcbmNvbnN0IGNyZWF0ZVN0b3JlID0gKCkgPT4ge1xuICBjb25zdCBhdG9tU3RhdGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgbW91bnRlZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBwZW5kaW5nU3RhY2sgPSBbXTtcbiAgY29uc3QgcGVuZGluZ01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBsZXQgc3RvcmVMaXN0ZW5lcnNSZXYyO1xuICBsZXQgbW91bnRlZEF0b21zO1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBzdG9yZUxpc3RlbmVyc1JldjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIG1vdW50ZWRBdG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbiAgY29uc3QgZ2V0QXRvbVN0YXRlID0gKGF0b20pID0+IGF0b21TdGF0ZU1hcC5nZXQoYXRvbSk7XG4gIGNvbnN0IGFkZFBlbmRpbmdEZXBlbmRlbnQgPSAoYXRvbSwgYXRvbVN0YXRlKSA9PiB7XG4gICAgYXRvbVN0YXRlLmQuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFwZW5kaW5nTWFwLmhhcyhhKSkge1xuICAgICAgICBjb25zdCBhU3RhdGUgPSBnZXRBdG9tU3RhdGUoYSk7XG4gICAgICAgIChfYSA9IHBlbmRpbmdTdGFja1twZW5kaW5nU3RhY2subGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5hZGQoYSk7XG4gICAgICAgIHBlbmRpbmdNYXAuc2V0KGEsIFthU3RhdGUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCldKTtcbiAgICAgICAgaWYgKGFTdGF0ZSkge1xuICAgICAgICAgIGFkZFBlbmRpbmdEZXBlbmRlbnQoYSwgYVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVuZGluZ01hcC5nZXQoYSlbMV0uYWRkKGF0b20pO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBzZXRBdG9tU3RhdGUgPSAoYXRvbSwgYXRvbVN0YXRlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgT2JqZWN0LmZyZWV6ZShhdG9tU3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGF0b21TdGF0ZU1hcC5zZXQoYXRvbSwgYXRvbVN0YXRlKTtcbiAgICBpZiAoIXBlbmRpbmdNYXAuaGFzKGF0b20pKSB7XG4gICAgICAoX2EgPSBwZW5kaW5nU3RhY2tbcGVuZGluZ1N0YWNrLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYWRkKGF0b20pO1xuICAgICAgcGVuZGluZ01hcC5zZXQoYXRvbSwgW3ByZXZBdG9tU3RhdGUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCldKTtcbiAgICAgIGFkZFBlbmRpbmdEZXBlbmRlbnQoYXRvbSwgYXRvbVN0YXRlKTtcbiAgICB9XG4gICAgaWYgKGhhc1Byb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSkpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBcInZcIiBpbiBhdG9tU3RhdGUgPyBhdG9tU3RhdGUudiBpbnN0YW5jZW9mIFByb21pc2UgPyBhdG9tU3RhdGUudiA6IFByb21pc2UucmVzb2x2ZShhdG9tU3RhdGUudikgOiBQcm9taXNlLnJlamVjdChhdG9tU3RhdGUuZSk7XG4gICAgICBpZiAocHJldkF0b21TdGF0ZS52ICE9PSBuZXh0KSB7XG4gICAgICAgIGNhbmNlbFByb21pc2UocHJldkF0b21TdGF0ZS52LCBuZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZURlcGVuZGVuY2llcyA9IChhdG9tLCBuZXh0QXRvbVN0YXRlLCBuZXh0RGVwZW5kZW5jaWVzLCBrZWVwUHJldmlvdXNEZXBlbmRlbmNpZXMpID0+IHtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBuZXcgTWFwKFxuICAgICAga2VlcFByZXZpb3VzRGVwZW5kZW5jaWVzID8gbmV4dEF0b21TdGF0ZS5kIDogbnVsbFxuICAgICk7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBuZXh0RGVwZW5kZW5jaWVzLmZvckVhY2goKGFTdGF0ZSwgYSkgPT4ge1xuICAgICAgaWYgKCFhU3RhdGUgJiYgaXNTZWxmQXRvbShhdG9tLCBhKSkge1xuICAgICAgICBhU3RhdGUgPSBuZXh0QXRvbVN0YXRlO1xuICAgICAgfVxuICAgICAgaWYgKGFTdGF0ZSkge1xuICAgICAgICBkZXBlbmRlbmNpZXMuc2V0KGEsIGFTdGF0ZSk7XG4gICAgICAgIGlmIChuZXh0QXRvbVN0YXRlLmQuZ2V0KGEpICE9PSBhU3RhdGUpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbQnVnXSBhdG9tIHN0YXRlIG5vdCBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlZCB8fCBuZXh0QXRvbVN0YXRlLmQuc2l6ZSAhPT0gZGVwZW5kZW5jaWVzLnNpemUpIHtcbiAgICAgIG5leHRBdG9tU3RhdGUuZCA9IGRlcGVuZGVuY2llcztcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldEF0b21WYWx1ZSA9IChhdG9tLCB2YWx1ZSwgbmV4dERlcGVuZGVuY2llcywga2VlcFByZXZpb3VzRGVwZW5kZW5jaWVzKSA9PiB7XG4gICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0ge1xuICAgICAgZDogKHByZXZBdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZBdG9tU3RhdGUuZCkgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIHY6IHZhbHVlXG4gICAgfTtcbiAgICBpZiAobmV4dERlcGVuZGVuY2llcykge1xuICAgICAgdXBkYXRlRGVwZW5kZW5jaWVzKFxuICAgICAgICBhdG9tLFxuICAgICAgICBuZXh0QXRvbVN0YXRlLFxuICAgICAgICBuZXh0RGVwZW5kZW5jaWVzLFxuICAgICAgICBrZWVwUHJldmlvdXNEZXBlbmRlbmNpZXNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc0VxdWFsQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpICYmIHByZXZBdG9tU3RhdGUuZCA9PT0gbmV4dEF0b21TdGF0ZS5kKSB7XG4gICAgICByZXR1cm4gcHJldkF0b21TdGF0ZTtcbiAgICB9XG4gICAgaWYgKGhhc1Byb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSkgJiYgaGFzUHJvbWlzZUF0b21WYWx1ZShuZXh0QXRvbVN0YXRlKSAmJiBpc0VxdWFsUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSkge1xuICAgICAgaWYgKHByZXZBdG9tU3RhdGUuZCA9PT0gbmV4dEF0b21TdGF0ZS5kKSB7XG4gICAgICAgIHJldHVybiBwcmV2QXRvbVN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEF0b21TdGF0ZS52ID0gcHJldkF0b21TdGF0ZS52O1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRBdG9tU3RhdGUoYXRvbSwgbmV4dEF0b21TdGF0ZSk7XG4gICAgcmV0dXJuIG5leHRBdG9tU3RhdGU7XG4gIH07XG4gIGNvbnN0IHNldEF0b21WYWx1ZU9yUHJvbWlzZSA9IChhdG9tLCB2YWx1ZU9yUHJvbWlzZSwgbmV4dERlcGVuZGVuY2llcywgYWJvcnRQcm9taXNlKSA9PiB7XG4gICAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWVPclByb21pc2UpKSB7XG4gICAgICBsZXQgY29udGludWVQcm9taXNlO1xuICAgICAgY29uc3QgdXBkYXRlUHJvbWlzZURlcGVuZGVuY2llcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICAgICAgaWYgKCFoYXNQcm9taXNlQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUpIHx8IHByZXZBdG9tU3RhdGUudiAhPT0gcHJvbWlzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0gc2V0QXRvbVZhbHVlKFxuICAgICAgICAgIGF0b20sXG4gICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICBuZXh0RGVwZW5kZW5jaWVzXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtb3VudGVkTWFwLmhhcyhhdG9tKSAmJiBwcmV2QXRvbVN0YXRlLmQgIT09IG5leHRBdG9tU3RhdGUuZCkge1xuICAgICAgICAgIG1vdW50RGVwZW5kZW5jaWVzKGF0b20sIG5leHRBdG9tU3RhdGUsIHByZXZBdG9tU3RhdGUuZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgc2V0dGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZU9yUHJvbWlzZS50aGVuKFxuICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNldHRsZWQpIHtcbiAgICAgICAgICAgICAgc2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKHByb21pc2UsIHYpO1xuICAgICAgICAgICAgICByZXNvbHZlKHYpO1xuICAgICAgICAgICAgICB1cGRhdGVQcm9taXNlRGVwZW5kZW5jaWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZXR0bGVkKSB7XG4gICAgICAgICAgICAgIHNldHRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICByZWplY3RQcm9taXNlKHByb21pc2UsIGUpO1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgIHVwZGF0ZVByb21pc2VEZXBlbmRlbmNpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGNvbnRpbnVlUHJvbWlzZSA9IChuZXh0KSA9PiB7XG4gICAgICAgICAgaWYgKCFzZXR0bGVkKSB7XG4gICAgICAgICAgICBzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5leHQudGhlbihcbiAgICAgICAgICAgICAgKHYpID0+IHJlc29sdmVQcm9taXNlKHByb21pc2UsIHYpLFxuICAgICAgICAgICAgICAoZSkgPT4gcmVqZWN0UHJvbWlzZShwcm9taXNlLCBlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlc29sdmUobmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBwcm9taXNlLm9yaWcgPSB2YWx1ZU9yUHJvbWlzZTtcbiAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICByZWdpc3RlckNhbmNlbFByb21pc2UocHJvbWlzZSwgKG5leHQpID0+IHtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBjb250aW51ZVByb21pc2UobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgYWJvcnRQcm9taXNlID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydFByb21pc2UoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNldEF0b21WYWx1ZShhdG9tLCBwcm9taXNlLCBuZXh0RGVwZW5kZW5jaWVzLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldEF0b21WYWx1ZShhdG9tLCB2YWx1ZU9yUHJvbWlzZSwgbmV4dERlcGVuZGVuY2llcyk7XG4gIH07XG4gIGNvbnN0IHNldEF0b21FcnJvciA9IChhdG9tLCBlcnJvciwgbmV4dERlcGVuZGVuY2llcykgPT4ge1xuICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHtcbiAgICAgIGQ6IChwcmV2QXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2QXRvbVN0YXRlLmQpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBlOiBlcnJvclxuICAgIH07XG4gICAgaWYgKG5leHREZXBlbmRlbmNpZXMpIHtcbiAgICAgIHVwZGF0ZURlcGVuZGVuY2llcyhhdG9tLCBuZXh0QXRvbVN0YXRlLCBuZXh0RGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgaWYgKGlzRXF1YWxBdG9tRXJyb3IocHJldkF0b21TdGF0ZSwgbmV4dEF0b21TdGF0ZSkgJiYgcHJldkF0b21TdGF0ZS5kID09PSBuZXh0QXRvbVN0YXRlLmQpIHtcbiAgICAgIHJldHVybiBwcmV2QXRvbVN0YXRlO1xuICAgIH1cbiAgICBzZXRBdG9tU3RhdGUoYXRvbSwgbmV4dEF0b21TdGF0ZSk7XG4gICAgcmV0dXJuIG5leHRBdG9tU3RhdGU7XG4gIH07XG4gIGNvbnN0IHJlYWRBdG9tU3RhdGUgPSAoYXRvbSwgZm9yY2UpID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKCFmb3JjZSAmJiBhdG9tU3RhdGUpIHtcbiAgICAgIGlmIChtb3VudGVkTWFwLmhhcyhhdG9tKSkge1xuICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmZyb20oYXRvbVN0YXRlLmQpLmV2ZXJ5KChbYSwgc10pID0+IHtcbiAgICAgICAgaWYgKGEgPT09IGF0b20pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhU3RhdGUgPSByZWFkQXRvbVN0YXRlKGEpO1xuICAgICAgICByZXR1cm4gYVN0YXRlID09PSBzIHx8IGlzRXF1YWxBdG9tVmFsdWUoYVN0YXRlLCBzKTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5leHREZXBlbmRlbmNpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBpc1N5bmMgPSB0cnVlO1xuICAgIGNvbnN0IGdldHRlciA9IChhKSA9PiB7XG4gICAgICBpZiAoaXNTZWxmQXRvbShhdG9tLCBhKSkge1xuICAgICAgICBjb25zdCBhU3RhdGUyID0gZ2V0QXRvbVN0YXRlKGEpO1xuICAgICAgICBpZiAoYVN0YXRlMikge1xuICAgICAgICAgIG5leHREZXBlbmRlbmNpZXMuc2V0KGEsIGFTdGF0ZTIpO1xuICAgICAgICAgIHJldHVybiByZXR1cm5BdG9tVmFsdWUoYVN0YXRlMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0luaXRpYWxWYWx1ZShhKSkge1xuICAgICAgICAgIG5leHREZXBlbmRlbmNpZXMuc2V0KGEsIHZvaWQgMCk7XG4gICAgICAgICAgcmV0dXJuIGEuaW5pdDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBhdG9tIGluaXRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBhU3RhdGUgPSByZWFkQXRvbVN0YXRlKGEpO1xuICAgICAgbmV4dERlcGVuZGVuY2llcy5zZXQoYSwgYVN0YXRlKTtcbiAgICAgIHJldHVybiByZXR1cm5BdG9tVmFsdWUoYVN0YXRlKTtcbiAgICB9O1xuICAgIGxldCBjb250cm9sbGVyO1xuICAgIGxldCBzZXRTZWxmO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgc2lnbmFsKCkge1xuICAgICAgICBpZiAoIWNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbiAgICAgIH0sXG4gICAgICBnZXQgc2V0U2VsZigpIHtcbiAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0U2VsZiBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIHJlYWQtb25seSBhdG9tXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2V0U2VsZiAmJiBpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgICAgc2V0U2VsZiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTeW5jKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNldFNlbGYgZnVuY3Rpb24gY2Fubm90IGJlIGNhbGxlZCBpbiBzeW5jXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1N5bmMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlQXRvbShhdG9tLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRTZWxmO1xuICAgICAgfVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbHVlT3JQcm9taXNlID0gYXRvbS5yZWFkKGdldHRlciwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gc2V0QXRvbVZhbHVlT3JQcm9taXNlKFxuICAgICAgICBhdG9tLFxuICAgICAgICB2YWx1ZU9yUHJvbWlzZSxcbiAgICAgICAgbmV4dERlcGVuZGVuY2llcyxcbiAgICAgICAgKCkgPT4gY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5hYm9ydCgpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gc2V0QXRvbUVycm9yKGF0b20sIGVycm9yLCBuZXh0RGVwZW5kZW5jaWVzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNTeW5jID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBjb25zdCByZWFkQXRvbSA9IChhdG9tKSA9PiByZXR1cm5BdG9tVmFsdWUocmVhZEF0b21TdGF0ZShhdG9tKSk7XG4gIGNvbnN0IGFkZEF0b20gPSAoYXRvbSkgPT4ge1xuICAgIGxldCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gICAgaWYgKCFtb3VudGVkKSB7XG4gICAgICBtb3VudGVkID0gbW91bnRBdG9tKGF0b20pO1xuICAgIH1cbiAgICByZXR1cm4gbW91bnRlZDtcbiAgfTtcbiAgY29uc3QgY2FuVW5tb3VudEF0b20gPSAoYXRvbSwgbW91bnRlZCkgPT4gIW1vdW50ZWQubC5zaXplICYmICghbW91bnRlZC50LnNpemUgfHwgbW91bnRlZC50LnNpemUgPT09IDEgJiYgbW91bnRlZC50LmhhcyhhdG9tKSk7XG4gIGNvbnN0IGRlbEF0b20gPSAoYXRvbSkgPT4ge1xuICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhdG9tKTtcbiAgICBpZiAobW91bnRlZCAmJiBjYW5Vbm1vdW50QXRvbShhdG9tLCBtb3VudGVkKSkge1xuICAgICAgdW5tb3VudEF0b20oYXRvbSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZWNvbXB1dGVEZXBlbmRlbnRzID0gKGF0b20pID0+IHtcbiAgICBjb25zdCBnZXREZXBlbmRlbnRzID0gKGEpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBkZXBlbmRlbnRzID0gbmV3IFNldCgoX2EgPSBtb3VudGVkTWFwLmdldChhKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnQpO1xuICAgICAgKF9iID0gcGVuZGluZ01hcC5nZXQoYSkpID09IG51bGwgPyB2b2lkIDAgOiBfYlsxXS5mb3JFYWNoKChkZXBlbmRlbnQpID0+IHtcbiAgICAgICAgZGVwZW5kZW50cy5hZGQoZGVwZW5kZW50KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRlcGVuZGVudHM7XG4gICAgfTtcbiAgICBjb25zdCB0b3Bzb3J0ZWRBdG9tcyA9IG5ldyBBcnJheSgpO1xuICAgIGNvbnN0IG1hcmtlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB2aXNpdCA9IChuKSA9PiB7XG4gICAgICBpZiAobWFya2VkQXRvbXMuaGFzKG4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hcmtlZEF0b21zLmFkZChuKTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBnZXREZXBlbmRlbnRzKG4pKSB7XG4gICAgICAgIGlmIChuICE9PSBtKSB7XG4gICAgICAgICAgdmlzaXQobSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRvcHNvcnRlZEF0b21zLnB1c2gobik7XG4gICAgfTtcbiAgICB2aXNpdChhdG9tKTtcbiAgICBjb25zdCBjaGFuZ2VkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbYXRvbV0pO1xuICAgIGZvciAobGV0IGkgPSB0b3Bzb3J0ZWRBdG9tcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgYSA9IHRvcHNvcnRlZEF0b21zW2ldO1xuICAgICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgIGlmICghcHJldkF0b21TdGF0ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBoYXNDaGFuZ2VkRGVwcyA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBkZXAgb2YgcHJldkF0b21TdGF0ZS5kLmtleXMoKSkge1xuICAgICAgICBpZiAoZGVwICE9PSBhICYmIGNoYW5nZWRBdG9tcy5oYXMoZGVwKSkge1xuICAgICAgICAgIGhhc0NoYW5nZWREZXBzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc0NoYW5nZWREZXBzKSB7XG4gICAgICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSByZWFkQXRvbVN0YXRlKGEsIHRydWUpO1xuICAgICAgICBpZiAoIWlzRXF1YWxBdG9tVmFsdWUocHJldkF0b21TdGF0ZSwgbmV4dEF0b21TdGF0ZSkpIHtcbiAgICAgICAgICBjaGFuZ2VkQXRvbXMuYWRkKGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCB3cml0ZUF0b21TdGF0ZSA9IChhdG9tLCAuLi5hcmdzKSA9PiB7XG4gICAgbGV0IGlzU3luYyA9IHRydWU7XG4gICAgY29uc3QgZ2V0dGVyID0gKGEpID0+IHJldHVybkF0b21WYWx1ZShyZWFkQXRvbVN0YXRlKGEpKTtcbiAgICBjb25zdCBzZXR0ZXIgPSAoYSwgLi4uYXJnczIpID0+IHtcbiAgICAgIGxldCByO1xuICAgICAgaWYgKGlzU2VsZkF0b20oYXRvbSwgYSkpIHtcbiAgICAgICAgaWYgKCFoYXNJbml0aWFsVmFsdWUoYSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdG9tIG5vdCB3cml0YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGEpO1xuICAgICAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0gc2V0QXRvbVZhbHVlT3JQcm9taXNlKGEsIGFyZ3MyWzBdKTtcbiAgICAgICAgaWYgKCFpc0VxdWFsQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpKSB7XG4gICAgICAgICAgcmVjb21wdXRlRGVwZW5kZW50cyhhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IHdyaXRlQXRvbVN0YXRlKGEsIC4uLmFyZ3MyKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNTeW5jKSB7XG4gICAgICAgIGNvbnN0IGZsdXNoZWQgPSBmbHVzaFBlbmRpbmcoW2FdKTtcbiAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgc3RvcmVMaXN0ZW5lcnNSZXYyLmZvckVhY2goXG4gICAgICAgICAgICAobCkgPT4gbCh7IHR5cGU6IFwiYXN5bmMtd3JpdGVcIiwgZmx1c2hlZCB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gYXRvbS53cml0ZShnZXR0ZXIsIHNldHRlciwgLi4uYXJncyk7XG4gICAgaXNTeW5jID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgY29uc3Qgd3JpdGVBdG9tID0gKGF0b20sIC4uLmFyZ3MpID0+IHtcbiAgICBwZW5kaW5nU3RhY2sucHVzaCgvKiBAX19QVVJFX18gKi8gbmV3IFNldChbYXRvbV0pKTtcbiAgICBjb25zdCByZXN1bHQgPSB3cml0ZUF0b21TdGF0ZShhdG9tLCAuLi5hcmdzKTtcbiAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKHBlbmRpbmdTdGFjay5wb3AoKSk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBzdG9yZUxpc3RlbmVyc1JldjIuZm9yRWFjaCgobCkgPT4gbCh7IHR5cGU6IFwid3JpdGVcIiwgZmx1c2hlZCB9KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IG1vdW50QXRvbSA9IChhdG9tLCBpbml0aWFsRGVwZW5kZW50LCBvbk1vdW50UXVldWUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcXVldWUgPSBvbk1vdW50UXVldWUgfHwgW107XG4gICAgKF9hID0gZ2V0QXRvbVN0YXRlKGF0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZC5mb3JFYWNoKChfLCBhKSA9PiB7XG4gICAgICBjb25zdCBhTW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgaWYgKGFNb3VudGVkKSB7XG4gICAgICAgIGFNb3VudGVkLnQuYWRkKGF0b20pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGEgIT09IGF0b20pIHtcbiAgICAgICAgICBtb3VudEF0b20oYSwgYXRvbSwgcXVldWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVhZEF0b21TdGF0ZShhdG9tKTtcbiAgICBjb25zdCBtb3VudGVkID0ge1xuICAgICAgdDogbmV3IFNldChpbml0aWFsRGVwZW5kZW50ICYmIFtpbml0aWFsRGVwZW5kZW50XSksXG4gICAgICBsOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgfTtcbiAgICBtb3VudGVkTWFwLnNldChhdG9tLCBtb3VudGVkKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIG1vdW50ZWRBdG9tcy5hZGQoYXRvbSk7XG4gICAgfVxuICAgIGlmIChpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pICYmIGF0b20ub25Nb3VudCkge1xuICAgICAgY29uc3QgeyBvbk1vdW50IH0gPSBhdG9tO1xuICAgICAgcXVldWUucHVzaCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9uVW5tb3VudCA9IG9uTW91bnQoKC4uLmFyZ3MpID0+IHdyaXRlQXRvbShhdG9tLCAuLi5hcmdzKSk7XG4gICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICBtb3VudGVkLnUgPSBvblVubW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW9uTW91bnRRdWV1ZSkge1xuICAgICAgcXVldWUuZm9yRWFjaCgoZikgPT4gZigpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vdW50ZWQ7XG4gIH07XG4gIGNvbnN0IHVubW91bnRBdG9tID0gKGF0b20pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgb25Vbm1vdW50ID0gKF9hID0gbW91bnRlZE1hcC5nZXQoYXRvbSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS51O1xuICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgIG9uVW5tb3VudCgpO1xuICAgIH1cbiAgICBtb3VudGVkTWFwLmRlbGV0ZShhdG9tKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIG1vdW50ZWRBdG9tcy5kZWxldGUoYXRvbSk7XG4gICAgfVxuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBpZiAoYXRvbVN0YXRlKSB7XG4gICAgICBpZiAoaGFzUHJvbWlzZUF0b21WYWx1ZShhdG9tU3RhdGUpKSB7XG4gICAgICAgIGNhbmNlbFByb21pc2UoYXRvbVN0YXRlLnYpO1xuICAgICAgfVxuICAgICAgYXRvbVN0YXRlLmQuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgICBpZiAoYSAhPT0gYXRvbSkge1xuICAgICAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgbW91bnRlZC50LmRlbGV0ZShhdG9tKTtcbiAgICAgICAgICAgIGlmIChjYW5Vbm1vdW50QXRvbShhLCBtb3VudGVkKSkge1xuICAgICAgICAgICAgICB1bm1vdW50QXRvbShhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltCdWddIGNvdWxkIG5vdCBmaW5kIGF0b20gc3RhdGUgdG8gdW5tb3VudFwiLCBhdG9tKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50RGVwZW5kZW5jaWVzID0gKGF0b20sIGF0b21TdGF0ZSwgcHJldkRlcGVuZGVuY2llcykgPT4ge1xuICAgIGNvbnN0IGRlcFNldCA9IG5ldyBTZXQoYXRvbVN0YXRlLmQua2V5cygpKTtcbiAgICBjb25zdCBtYXliZVVubW91bnRBdG9tU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBwcmV2RGVwZW5kZW5jaWVzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2RGVwZW5kZW5jaWVzLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgIGlmIChkZXBTZXQuaGFzKGEpKSB7XG4gICAgICAgIGRlcFNldC5kZWxldGUoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1heWJlVW5tb3VudEF0b21TZXQuYWRkKGEpO1xuICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgbW91bnRlZC50LmRlbGV0ZShhdG9tKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZXBTZXQuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgbW91bnRlZC50LmFkZChhdG9tKTtcbiAgICAgIH0gZWxzZSBpZiAobW91bnRlZE1hcC5oYXMoYXRvbSkpIHtcbiAgICAgICAgbW91bnRBdG9tKGEsIGF0b20pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1heWJlVW5tb3VudEF0b21TZXQuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgaWYgKG1vdW50ZWQgJiYgY2FuVW5tb3VudEF0b20oYSwgbW91bnRlZCkpIHtcbiAgICAgICAgdW5tb3VudEF0b20oYSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGZsdXNoUGVuZGluZyA9IChwZW5kaW5nQXRvbXMpID0+IHtcbiAgICBsZXQgZmx1c2hlZDtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGZsdXNoZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgY29sbGVjdFBlbmRpbmcgPSAocGVuZGluZ0F0b20pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghcGVuZGluZ01hcC5oYXMocGVuZGluZ0F0b20pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtwcmV2QXRvbVN0YXRlLCBkZXBlbmRlbnRzXSA9IHBlbmRpbmdNYXAuZ2V0KHBlbmRpbmdBdG9tKTtcbiAgICAgIHBlbmRpbmdNYXAuZGVsZXRlKHBlbmRpbmdBdG9tKTtcbiAgICAgIHBlbmRpbmcucHVzaChbcGVuZGluZ0F0b20sIHByZXZBdG9tU3RhdGVdKTtcbiAgICAgIGRlcGVuZGVudHMuZm9yRWFjaChjb2xsZWN0UGVuZGluZyk7XG4gICAgICAoX2EgPSBnZXRBdG9tU3RhdGUocGVuZGluZ0F0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZC5mb3JFYWNoKChfLCBhKSA9PiBjb2xsZWN0UGVuZGluZyhhKSk7XG4gICAgfTtcbiAgICBwZW5kaW5nQXRvbXMuZm9yRWFjaChjb2xsZWN0UGVuZGluZyk7XG4gICAgcGVuZGluZy5mb3JFYWNoKChbYXRvbSwgcHJldkF0b21TdGF0ZV0pID0+IHtcbiAgICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICAgIGlmICghYXRvbVN0YXRlKSB7XG4gICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIltCdWddIG5vIGF0b20gc3RhdGUgdG8gZmx1c2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGF0b21TdGF0ZSAhPT0gcHJldkF0b21TdGF0ZSkge1xuICAgICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gICAgICAgIGlmIChtb3VudGVkICYmIGF0b21TdGF0ZS5kICE9PSAocHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKSkge1xuICAgICAgICAgIG1vdW50RGVwZW5kZW5jaWVzKGF0b20sIGF0b21TdGF0ZSwgcHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW91bnRlZCAmJiAhLy8gVE9ETyBUaGlzIHNlZW1zIHByZXR0eSBoYWNreS4gSG9wZSB0byBmaXggaXQuXG4gICAgICAgIC8vIE1heWJlIHdlIGNvdWxkIGBtb3VudERlcGVuZGVuY2llc2AgaW4gYHNldEF0b21TdGF0ZWA/XG4gICAgICAgICghaGFzUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlKSAmJiAoaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBhdG9tU3RhdGUpIHx8IGlzRXF1YWxBdG9tRXJyb3IocHJldkF0b21TdGF0ZSwgYXRvbVN0YXRlKSkpKSB7XG4gICAgICAgICAgbW91bnRlZC5sLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcigpKTtcbiAgICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZsdXNoZWQuYWRkKGF0b20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmV0dXJuIGZsdXNoZWQ7XG4gICAgfVxuICB9O1xuICBjb25zdCBzdWJzY3JpYmVBdG9tID0gKGF0b20sIGxpc3RlbmVyKSA9PiB7XG4gICAgY29uc3QgbW91bnRlZCA9IGFkZEF0b20oYXRvbSk7XG4gICAgY29uc3QgZmx1c2hlZCA9IGZsdXNoUGVuZGluZyhbYXRvbV0pO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IG1vdW50ZWQubDtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHN0b3JlTGlzdGVuZXJzUmV2Mi5mb3JFYWNoKFxuICAgICAgICAobCkgPT4gbCh7IHR5cGU6IFwic3ViXCIsIGZsdXNoZWQgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIGRlbEF0b20oYXRvbSk7XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgc3RvcmVMaXN0ZW5lcnNSZXYyLmZvckVhY2goKGwpID0+IGwoeyB0eXBlOiBcInVuc3ViXCIgfSkpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQ6IHJlYWRBdG9tLFxuICAgICAgc2V0OiB3cml0ZUF0b20sXG4gICAgICBzdWI6IHN1YnNjcmliZUF0b20sXG4gICAgICAvLyBzdG9yZSBkZXYgbWV0aG9kcyAodGhlc2UgYXJlIHRlbnRhdGl2ZSBhbmQgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UpXG4gICAgICBkZXZfc3Vic2NyaWJlX3N0b3JlOiAobCwgcmV2KSA9PiB7XG4gICAgICAgIGlmIChyZXYgIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCBTdG9yZUxpc3RlbmVyIHJldmlzaW9uIGlzIDIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlTGlzdGVuZXJzUmV2Mi5hZGQobCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgc3RvcmVMaXN0ZW5lcnNSZXYyLmRlbGV0ZShsKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBkZXZfZ2V0X21vdW50ZWRfYXRvbXM6ICgpID0+IG1vdW50ZWRBdG9tcy52YWx1ZXMoKSxcbiAgICAgIGRldl9nZXRfYXRvbV9zdGF0ZTogKGEpID0+IGF0b21TdGF0ZU1hcC5nZXQoYSksXG4gICAgICBkZXZfZ2V0X21vdW50ZWQ6IChhKSA9PiBtb3VudGVkTWFwLmdldChhKSxcbiAgICAgIGRldl9yZXN0b3JlX2F0b21zOiAodmFsdWVzKSA9PiB7XG4gICAgICAgIHBlbmRpbmdTdGFjay5wdXNoKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgICAgICBmb3IgKGNvbnN0IFthdG9tLCB2YWx1ZU9yUHJvbWlzZV0gb2YgdmFsdWVzKSB7XG4gICAgICAgICAgaWYgKGhhc0luaXRpYWxWYWx1ZShhdG9tKSkge1xuICAgICAgICAgICAgc2V0QXRvbVZhbHVlT3JQcm9taXNlKGF0b20sIHZhbHVlT3JQcm9taXNlKTtcbiAgICAgICAgICAgIHJlY29tcHV0ZURlcGVuZGVudHMoYXRvbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsdXNoZWQgPSBmbHVzaFBlbmRpbmcocGVuZGluZ1N0YWNrLnBvcCgpKTtcbiAgICAgICAgc3RvcmVMaXN0ZW5lcnNSZXYyLmZvckVhY2goXG4gICAgICAgICAgKGwpID0+IGwoeyB0eXBlOiBcInJlc3RvcmVcIiwgZmx1c2hlZCB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IHJlYWRBdG9tLFxuICAgIHNldDogd3JpdGVBdG9tLFxuICAgIHN1Yjogc3Vic2NyaWJlQXRvbVxuICB9O1xufTtcbmxldCBkZWZhdWx0U3RvcmU7XG5pZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLl9fTlVNQkVSX09GX0pPVEFJX0lOU1RBTkNFU19fID09PSBcIm51bWJlclwiKSB7XG4gICAgKytnbG9iYWxUaGlzLl9fTlVNQkVSX09GX0pPVEFJX0lOU1RBTkNFU19fO1xuICB9IGVsc2Uge1xuICAgIGdsb2JhbFRoaXMuX19OVU1CRVJfT0ZfSk9UQUlfSU5TVEFOQ0VTX18gPSAxO1xuICB9XG59XG5jb25zdCBnZXREZWZhdWx0U3RvcmUgPSAoKSA9PiB7XG4gIGlmICghZGVmYXVsdFN0b3JlKSB7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIGdsb2JhbFRoaXMuX19OVU1CRVJfT0ZfSk9UQUlfSU5TVEFOQ0VTX18gIT09IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSBKb3RhaSBpbnN0YW5jZXMuIEl0IG1heSBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9yIHdpdGggdGhlIGRlZmF1bHQgc3RvcmUuIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvam90YWkvZGlzY3Vzc2lvbnMvMjA0NFwiXG4gICAgICApO1xuICAgIH1cbiAgICBkZWZhdWx0U3RvcmUgPSBjcmVhdGVTdG9yZSgpO1xuICB9XG4gIHJldHVybiBkZWZhdWx0U3RvcmU7XG59O1xuXG5leHBvcnQgeyBhdG9tLCBjcmVhdGVTdG9yZSwgZ2V0RGVmYXVsdFN0b3JlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/vanilla.mjs\n");

/***/ })

};
;